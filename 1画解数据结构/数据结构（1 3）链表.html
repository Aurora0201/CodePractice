<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>❤️《画解数据结构》七个动图，画解链表❤️</title>
  <link rel="stylesheet" href="https://stackedit.io/style.css" />
</head>

<body class="stackedit">
  <div class="stackedit__html"><center>本文已收录于专栏</center><center> <a href="https://blog.csdn.net/whereisherofrom/category_11227297.html"><font color="13ae01"><b>🌳《<u>画解数据结构</u>》🌳 </b></font></a> </center><br>
<h1><a id="_2"></a>零、前言</h1>
<p>  目前本专栏正在进行优惠活动，在博主主页添加博主好友（好友位没有满的话），可以获取 <font color="red"><strong>付费专栏优惠券</strong></font>。</p>
<blockquote>
<p>  <font color="FF4500"><b>「 数据结构 」</b></font> 和 <font color="FFa700"><b>「 算法 」</b></font> 是密不可分的，两者往往是<font color="ffd700"><b>「 相辅相成 」</b></font>的存在，所以，在学习 <font color="FF4500"><b>「 数据结构 」</b></font> 的过程中，不免会遇到各种<font color="FFa700"><b>「 算法 」</b></font>。<br>  到底是先学 数据结构 ，还是先学 算法，我认为不必纠结这个问题，一定是一起学的。<br>  数据结构 常用的操作一般为：<font color="13ae01"><b>「 增 」</b></font><font color="FF0500"><b>「 删 」</b></font><font color="ffd700"><b>「 改 」</b></font><font color="2290ff"><b>「 查 」</b></font>。基本上所有的数据结构都是围绕这几个操作进行展开的。<br>  那么这篇文章，作者将用 <font color="13ae01"><b>「 七张动图 」</b></font> 来阐述一种最基础的链式结构<br><br> </p><center><font size="5" color="2290ff"><b>「  单向链表 」</b></font></center><br>
<img src="https://img-blog.csdnimg.cn/74095a84d29e4575a71ffa195e3fbecd.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1doZXJlSXNIZXJvRnJvbQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>
  今天要讲的内容，浓缩一下就是下面这张图：<br>
 <br>
<img src="https://img-blog.csdnimg.cn/a1f66250029a4a3ea996e40fafac90d1.gif#pic_center" alt=""><br>
  看不懂没有关系，我会把它拆开来一个一个讲，首先来看一些简单的概念。<p></p>
</blockquote>
<p></p><div class="toc"><h3>文章目录</h3><ul><li><a href="#_2">零、前言</a></li><li><a href="#_12">一、概念</a></li><ul><li><a href="#1_14">1、链表定义</a></li><li><a href="#2_21">2、结点结构体定义</a></li><li><a href="#3_34">3、结点的创建</a></li></ul><li><a href="#___50">二、链表的创建 - 尾插法</a></li><ul><li><a href="#1_52">1、算法描述</a></li><li><a href="#2_54">2、动画演示</a></li><li><a href="#3_59">3、源码详解</a></li></ul><li><a href="#___82">三、链表的创建 - 头插法</a></li><ul><li><a href="#1_83">1、算法描述</a></li><li><a href="#2_86">2、动画演示</a></li><li><a href="#3_89">3、源码详解</a></li></ul><li><a href="#_104">四、链表的打印</a></li><ul><li><a href="#1_105">1、打印的作用</a></li><li><a href="#2_109">2、源码详解</a></li><li><a href="#3_126">3、测试用例</a></li></ul><li><a href="#_152">五、链表元素的索引</a></li><ul><li><a href="#1_153">1、算法描述</a></li><li><a href="#2_156">2、动画演示</a></li><li><a href="#3_159">3、源码详解</a></li><li><a href="#4_181">4、测试用例</a></li><li><a href="#5_211">5、算法分析</a></li><ul><li><a href="#1_212">1）时间复杂度</a></li><li><a href="#2_214">2）空间复杂度</a></li></ul></ul><li><a href="#_216">六、链表元素的查找</a></li><ul><li><a href="#1_217">1、算法描述</a></li><li><a href="#2_220">2、动画演示</a></li><li><a href="#3_223">3、源码详解</a></li><li><a href="#4_242">4、测试用例</a></li><li><a href="#5_270">5、算法分析</a></li><ul><li><a href="#1_271">1）时间复杂度</a></li><li><a href="#2_273">2）空间复杂度</a></li></ul></ul><li><a href="#_275">七、链表结点的插入</a></li><ul><li><a href="#1_276">1、算法描述</a></li><li><a href="#2_279">2、动画演示</a></li><li><a href="#3_282">3、源码详解</a></li><li><a href="#4_312">4、测试用例</a></li><li><a href="#5_333">5、算法分析</a></li><ul><li><a href="#1_334">1）时间复杂度</a></li><li><a href="#2_336">2）空间复杂度</a></li></ul></ul><li><a href="#_338">八、链表结点的删除</a></li><ul><li><a href="#1_339">1、算法描述</a></li><li><a href="#2_348">2、动画演示</a></li><li><a href="#3_351">3、源码详解</a></li><li><a href="#4_395">4、测试用例</a></li><li><a href="#5_423">5、算法分析</a></li><ul><li><a href="#1_424">1）时间复杂度</a></li><li><a href="#2_427">2）空间复杂度</a></li></ul></ul><li><a href="#_429">九、链表的销毁</a></li><ul><li><a href="#1_430">1、算法描述</a></li><li><a href="#2_433">2、动画演示</a></li><li><a href="#3_436">3、源码详解</a></li><li><a href="#4_451">4、测试用例</a></li><li><a href="#5_483">5、算法分析</a></li><ul><li><a href="#1_484">1）时间复杂度</a></li><li><a href="#2_487">2）空间复杂度</a></li></ul></ul><li><a href="#_489">十、链表的优缺点</a></li><ul><li><a href="#1_490">1、优点</a></li><li><a href="#2_492">2、缺点</a></li></ul></ul></div><p></p>
<h1><a id="_12"></a>一、概念</h1>
<ul>
<li>对于顺序存储的结构，如数组，最大的缺点就是：<strong>插入</strong> 和 <strong>删除</strong> 的时候需要移动大量的元素。所以，基于前人的智慧，他们发明了链表。</li>
</ul>
<h2><a id="1_14"></a>1、链表定义</h2>
<blockquote>
<p>  <strong>链表</strong> 是由一个个 <strong>结点</strong> 组成，每个 <strong>结点</strong> 之间通过 <strong>链接关系</strong> 串联起来，每个 <strong>结点</strong> 都有一个 <strong>后继节点</strong>，最后一个 <strong>结点</strong> 的 <strong>后继结点</strong> 为 <strong>空结点</strong>。如下图所示：</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/img_convert/10485d3373089b13fe59fadf925e43c0.png#pic_center" alt=""></p>
<ul>
<li>由链接关系<code>A -&gt; B</code>组织起来的两个结点，<code>B</code>被称为<code>A</code>的后继结点，<code>A</code>被称为<code>B</code>的前驱结点。</li>
<li><strong>链表</strong> 分为 <strong>单向链表</strong>、<strong>双向链表</strong>、<strong>循环链表</strong> 等等，本文要介绍的链表是 <strong>单向链表</strong>。</li>
<li>由于链表是由一个个 <strong>结点</strong> 组成，所以我们先来看下 <strong>结点</strong> 的实现。</li>
</ul>
<h2><a id="2_21"></a>2、结点结构体定义</h2>
<pre><code class="prism language-c"><span class="token keyword">typedef</span> <span class="token keyword">int</span> DataType<span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token class-name">ListNode</span> <span class="token punctuation">{</span>
    DataType data<span class="token punctuation">;</span>  <span class="token comment">// (1)</span>
    ListNode <span class="token operator">*</span>next<span class="token punctuation">;</span> <span class="token comment">// (2)</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre>
<ul>
<li><span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span> <strong>数据域</strong>：可以是任意类型，由编码的人自行指定；这段代码中，利用<code>typedef</code>将它和<code>int</code>同名，本文的 <strong>数据域</strong> 也会全部采用<code>int</code>类型进行讲解；</li>
<li><span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mn>2</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">2</span><span class="mclose">)</span></span></span></span></span> <strong>指针域</strong>：指向 <strong>后继结点</strong> 的地址；</li>
<li>一个结点包含的两部分如下图所示：<br>
<img src="https://img-blog.csdnimg.cn/img_convert/255454fa46f752e8f22496983f59e932.png#pic_center" alt="在这里插入图片描述"></li>
</ul>
<h2><a id="3_34"></a>3、结点的创建</h2>
<ul>
<li>我们通过 C语言 中的库函数<code>malloc</code>来创建一个 <strong>链表结点</strong>，然后对 <strong>数据域</strong> 和 <strong>指针域</strong> 进行赋值，代码实现如下：</li>
</ul>
<pre><code class="prism language-c">ListNode <span class="token operator">*</span><span class="token function">ListCreateNode</span><span class="token punctuation">(</span>DataType data<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    ListNode <span class="token operator">*</span>node <span class="token operator">=</span> <span class="token punctuation">(</span>ListNode <span class="token operator">*</span><span class="token punctuation">)</span> <span class="token function">malloc</span> <span class="token punctuation">(</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>ListNode<span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// (1)</span>
    node<span class="token operator">-&gt;</span>data <span class="token operator">=</span> data<span class="token punctuation">;</span>                                         <span class="token comment">// (2)</span>
    node<span class="token operator">-&gt;</span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>                                         <span class="token comment">// (3)</span>
    <span class="token keyword">return</span> node<span class="token punctuation">;</span>                                               <span class="token comment">// (4)</span>
<span class="token punctuation">}</span>
</code></pre>
<ul>
<li><span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span> 利用系统库函数<code>malloc</code>分配一块内存空间，用来存放<code>ListNode</code>即链表结点对象；</li>
<li><span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mn>2</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">2</span><span class="mclose">)</span></span></span></span></span> 将 <strong>数据域</strong> 置为函数传参<code>data</code>；</li>
<li><span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mn>3</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">3</span><span class="mclose">)</span></span></span></span></span> 将 <strong>指针域</strong> 置空，代表这是一个孤立的 <strong>链表结点</strong>；</li>
<li><span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mn>4</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(4)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">4</span><span class="mclose">)</span></span></span></span></span> 返回这个结点的指针。</li>
<li>创建完毕以后，这个孤立结点如下所示：<br>
<img src="https://img-blog.csdnimg.cn/92a5e6195224479f8b1bedd6c4624a4d.png#pic_center" alt=""></li>
</ul>
<h1><a id="___50"></a>二、链表的创建 - 尾插法</h1>
<ul>
<li>那么接下来，让我们看下如何通过一个 <strong>数组中的数据</strong> 来创建一个链表。</li>
</ul>
<h2><a id="1_52"></a>1、算法描述</h2>
<blockquote>
<p>  首先介绍 <strong>尾插法</strong> ，顾名思义，即 <strong>从链表尾部插入</strong> 的意思，就是记录一个 <strong>链表尾结点</strong>，然后遍历给定数组，将数组元素一个一个插到链表的尾部，每插入一个结点，则将它更新为新的 <strong>链表尾结点</strong>。注意初始情况下，<strong>链表尾结点</strong> 为空。</p>
</blockquote>
<h2><a id="2_54"></a>2、动画演示</h2>
<p><img src="https://img-blog.csdnimg.cn/8d0ce73e12ae4cf8b9761efc147775dd.gif#pic_center" alt=""></p>
<blockquote>
<p>上图演示的是 <strong>尾插法</strong> 的整个过程，其中：<br>  <font color="red"><b>head</b></font> 代表链表头结点，创建完一个结点以后，它就保持不变了；<br>  <font color="red"><b>tail</b></font> 代表链表尾结点，即动图中的 <font color="52bc69"><b>绿色结点</b></font>；<br>  <font color="red"><b>vtx</b></font> 代表正在插入链表尾部的结点，即动图中的 <font color="fe8a27"><b>橙色结点</b></font>，插入完毕以后，<font color="red"><b>vtx</b></font> 变成 <font color="red"><b>tail</b></font>；</p>
</blockquote>
<ul>
<li>看完这个动图，你应该已经大致理解了 <strong>链表的创建过程</strong>。那么接下来，我们用程序语言来描述一下整个过程，这里采用的是 <strong>C语言</strong> 的形式，如果你是 Java、C#、Python 技术栈的，也可以试着写出自己的版本。</li>
<li>语言并不是关键，思维才是关键。</li>
</ul>
<h2><a id="3_59"></a>3、源码详解</h2>
<ul>
<li>C语言 实现如下：</li>
</ul>
<pre><code class="prism language-c">ListNode <span class="token operator">*</span><span class="token function">ListCreateListByTail</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    ListNode <span class="token operator">*</span>head<span class="token punctuation">,</span> <span class="token operator">*</span>tail<span class="token punctuation">,</span> <span class="token operator">*</span>vtx<span class="token punctuation">;</span>         <span class="token comment">// (1) </span>
    <span class="token keyword">int</span> idx<span class="token punctuation">;</span>                              
    <span class="token keyword">if</span><span class="token punctuation">(</span>n <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>                     <span class="token comment">// (2) </span>
    idx <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    vtx <span class="token operator">=</span> <span class="token function">ListCreateNode</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment">// (3) </span>
    head <span class="token operator">=</span> tail <span class="token operator">=</span> vtx<span class="token punctuation">;</span>                   <span class="token comment">// (4)  </span>
    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">++</span>idx <span class="token operator">&lt;</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>                   <span class="token comment">// (5) </span>
        vtx <span class="token operator">=</span> <span class="token function">ListCreateNode</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// (6) </span>
        tail<span class="token operator">-&gt;</span>next <span class="token operator">=</span> vtx<span class="token punctuation">;</span>                <span class="token comment">// (7) </span>
        tail <span class="token operator">=</span> vtx<span class="token punctuation">;</span>                      <span class="token comment">// (8)  </span>
    <span class="token punctuation">}</span> 
    <span class="token keyword">return</span> head<span class="token punctuation">;</span>                         <span class="token comment">// (9) </span>
<span class="token punctuation">}</span> 
</code></pre>
<blockquote>
<p>对应的注释如下：<br>  <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span> <code>head</code>存储头结点的地址，<code>tail</code>存储尾结点的地址，<code>vtx</code>存储当前正在插入结点的地址； <br>  <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mn>2</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">2</span><span class="mclose">)</span></span></span></span></span> 当需要创建的元素个数为 0 时，直接返回空链表； <br>  <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mn>3</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">3</span><span class="mclose">)</span></span></span></span></span> 创建一个 <strong>数据域</strong> 为<code>a[0]</code>的链表结点；<br>  <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mn>4</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(4)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">4</span><span class="mclose">)</span></span></span></span></span>  由于初始情况下只有一个结点，所以将链表头结点<code>head</code>和链表尾结点<code>tail</code>都置为<code>vtx</code>；<br>  <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mn>5</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(5)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">5</span><span class="mclose">)</span></span></span></span></span> 从数组第 1 个元素 (0 - based) 开始，循环遍历数组；<br>  <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mn>6</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(6)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">6</span><span class="mclose">)</span></span></span></span></span>  由于数组中第 0 个元素已经创建过了，所以这里只需要对除了第 0 个元素以外的数据创建链表结点； <br>  <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mn>7</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(7)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">7</span><span class="mclose">)</span></span></span></span></span> 结点创建出来后，将当前链表尾结点<code>tail</code>的 <strong>后继结点</strong> 置为<code>vtx</code>；<br>  <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mn>8</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(8)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">8</span><span class="mclose">)</span></span></span></span></span> 将最近创建的结点<code>vtx</code>作为新的 <strong>链表尾结点</strong>；<br>  <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mn>9</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(9)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">9</span><span class="mclose">)</span></span></span></span></span> 返回链表头结点；</p>
</blockquote>
<hr>
<ul>
<li><strong>尾插法</strong> 比较符合直观的思维逻辑，但是就代码量来说还是有点长（注意：在实现相同功能的情况下，代码应该是越简洁，越简单越好的）。</li>
<li>于是，我们引入了另一种创建链表的方式 —— 头插法。</li>
</ul>
<h1><a id="___82"></a>三、链表的创建 - 头插法</h1>
<h2><a id="1_83"></a>1、算法描述</h2>
<blockquote>
<p>  <strong>头插法</strong>，顾名思义，就是每次从头结点前面进行插入，但是这样一来，就会导致插入的数据元素是 <strong>逆序</strong> 的，所以我们需要 <strong>逆序访问数组</strong> 执行插入，此所谓 <strong>负负得正</strong> 的思想。</p>
</blockquote>
<ul>
<li>它的特点是代码量短，且 <strong>常数时间复杂度</strong> 低。虽然没有 <strong>尾插法</strong> 那么直观，但是代码简洁，更加容易阅读。</li>
</ul>
<h2><a id="2_86"></a>2、动画演示</h2>
<p><img src="https://img-blog.csdnimg.cn/75e4131224d24a159d20f44bf8808509.gif#pic_center" alt=""></p>
<blockquote>
<p>上图所示的是 <strong>头插法</strong> 的整个插入过程，其中：<br>  <font color="red"><b>head</b></font> 代表链表头结点，即动图中的 <font color="52bc69"><b>绿色结点</b></font>，每新加一个结点，头结点就变成了新加入的结点；<br>  <font color="red"><b>tail</b></font> 代表链表尾结点，创建完一个结点以后，它就保持不变了；<br>  <font color="red"><b>vtx</b></font> 代表正在插入链表头部的结点，即动图中的 <font color="fe8a27"><b>橙色结点</b></font>，插入完毕以后，<font color="red"><b>vtx</b></font> 变成 <font color="red"><b>head</b></font>；</p>
</blockquote>
<h2><a id="3_89"></a>3、源码详解</h2>
<pre><code class="prism language-c">ListNode <span class="token operator">*</span><span class="token function">ListCreateListByHead</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>a<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    ListNode <span class="token operator">*</span>head <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token operator">*</span>vtx<span class="token punctuation">;</span>       <span class="token comment">// (1) </span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>n<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                       <span class="token comment">// (2) </span>
        vtx <span class="token operator">=</span> <span class="token function">ListCreateNode</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// (3) </span>
        vtx<span class="token operator">-&gt;</span>next <span class="token operator">=</span> head<span class="token punctuation">;</span>              <span class="token comment">// (4) </span>
        head <span class="token operator">=</span> vtx<span class="token punctuation">;</span>                    <span class="token comment">// (5) </span>
    <span class="token punctuation">}</span> 
    <span class="token keyword">return</span> head<span class="token punctuation">;</span>                       <span class="token comment">// (6) </span>
<span class="token punctuation">}</span> 
</code></pre>
<blockquote>
<p>对应的注释如下：<br>  <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span> <code>head</code>存储头结点的地址，初始为空链表， <code>vtx</code>存储当前正在插入结点的地址； <br>  <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mn>2</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">2</span><span class="mclose">)</span></span></span></span></span> 总共需要插入 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">n</span></span></span></span></span> 个结点，所以采用逆序的 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">n</span></span></span></span></span> 次循环； <br>  <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mn>3</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">3</span><span class="mclose">)</span></span></span></span></span> 创建一个元素值为<code>a[i]</code>的链表结点，注意，由于逆序，所以这里 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.65952em; vertical-align: 0em;"></span><span class="mord mathdefault">i</span></span></span></span></span> 的取值为 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn><mo>→</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">n-1 \to 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.66666em; vertical-align: -0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">0</span></span></span></span></span>； <br>  <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mn>4</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(4)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">4</span><span class="mclose">)</span></span></span></span></span>  将当前创建的结点的 <strong>后继结点</strong> 置为 链表的头结点<code>head</code>； <br>  <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mn>5</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(5)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">5</span><span class="mclose">)</span></span></span></span></span> 将链表头结点<code>head</code>置为<code>vtx</code>； <br>  <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mn>6</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(6)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">6</span><span class="mclose">)</span></span></span></span></span>  返回链表头结点；</p>
</blockquote>
<hr>
<ul>
<li><strong>头插法</strong> 的代码量比 <strong>尾插法</strong> 少了三分之一，而且将 <strong>创建结点的逻辑</strong> 统一起来了。这句话什么意思呢？仔细观察可以发现，<strong>尾插法</strong> 在实现过程中，<code>ListCreateNode</code>在代码里出现了两次，而 <strong>头插法</strong> 只出现了一次，将流程简化了，所以还是推荐使用 <strong>头插法</strong>。</li>
</ul>
<h1><a id="_104"></a>四、链表的打印</h1>
<h2><a id="1_105"></a>1、打印的作用</h2>
<ul>
<li><strong>可视化</strong> 能够帮助我们更好的理解数据结构。所以，对于一种数据结构，如何通过 <strong>输出函数</strong> 将它 <strong>打印到控制台</strong> 上，就成了我们接下来要做的事情。</li>
<li>我会用 C语言 来实现，但是只要你掌握了这套自己验证的方法，那么就算用其他语言，一样可以验证自己代码的正确性。</li>
</ul>
<blockquote>
<p>那么，如何打印一个链表呢？我们可以这么思考：<br>  链表的每个结点都有一个 <strong>后继结点</strong> ，我们可以用<code>A -&gt; B</code>代表结点<code>B</code>是结点<code>A</code>的 <strong>后继结点</strong>，而对于最后一个结点而言，它的后继可以用<code>NULL</code>表示。所以，我们可以循环输出所有结点并且带上<code>-&gt;</code>，然后在最后加上<code>NULL</code>。</p>
</blockquote>
<h2><a id="2_109"></a>2、源码详解</h2>
<ul>
<li>C语言实现如下：</li>
</ul>
<pre><code class="prism language-c"><span class="token keyword">void</span> <span class="token function">ListPrint</span><span class="token punctuation">(</span>ListNode <span class="token operator">*</span>head<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    ListNode <span class="token operator">*</span>vtx <span class="token operator">=</span> head<span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>vtx<span class="token punctuation">)</span> <span class="token punctuation">{</span>                      <span class="token comment">// (1)</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d -&gt; "</span><span class="token punctuation">,</span> vtx<span class="token operator">-&gt;</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// (2) </span>
        vtx <span class="token operator">=</span> vtx<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>              <span class="token comment">// (3)</span>
    <span class="token punctuation">}</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"NULL\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token comment">// (4)</span>
<span class="token punctuation">}</span>
</code></pre>
<blockquote>
<p>对应的注释如下：<br>  <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span> 从头结点开始，循环遍历所有结点； <br>  <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mn>2</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">2</span><span class="mclose">)</span></span></span></span></span> 遍历到的结点，将结点的 <strong>数据域</strong> 带上<code>-&gt;</code>后输出;<br>  <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mn>3</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">3</span><span class="mclose">)</span></span></span></span></span> 将 <strong>当前结点</strong> 置为 <strong>当前结点</strong> 的 <strong>后继结点</strong>，继续迭代； <br>  <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mn>4</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(4)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">4</span><span class="mclose">)</span></span></span></span></span> 最后输出一个<code>NULL</code>，代表一个完整的链表；</p>
</blockquote>
<ul>
<li>对于上面例子中的链表，调用这个函数，得到的结果为：</li>
</ul>
<pre><code class="prism language-c"><span class="token number">1</span> <span class="token operator">-&gt;</span> <span class="token number">3</span> <span class="token operator">-&gt;</span> <span class="token number">8</span> <span class="token operator">-&gt;</span> <span class="token number">2</span> <span class="token operator">-&gt;</span> <span class="token number">6</span> <span class="token operator">-&gt;</span> <span class="token constant">NULL</span>
</code></pre>
<h2><a id="3_126"></a>3、测试用例</h2>
<ul>
<li>例如，我们在 <strong>头插法</strong> 的实现过程中，加上一句 <strong>链表的打印</strong> 语句，代码实现如下：</li>
</ul>
<pre><code class="prism language-c">ListNode <span class="token operator">*</span><span class="token function">ListCreateListByHead</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>a<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    ListNode <span class="token operator">*</span>head <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token operator">*</span>vtx<span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>n<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
        vtx <span class="token operator">=</span> <span class="token function">ListCreateNode</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        vtx<span class="token operator">-&gt;</span>next <span class="token operator">=</span> head<span class="token punctuation">;</span>
        head <span class="token operator">=</span> vtx<span class="token punctuation">;</span>
        <span class="token function">ListPrint</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/*看这里，看这里！*/</span>
    <span class="token punctuation">}</span> 
    <span class="token keyword">return</span> head<span class="token punctuation">;</span>
<span class="token punctuation">}</span> 
</code></pre>
<ul>
<li>运行后得到的结果如下：</li>
</ul>
<pre><code class="prism language-c"><span class="token number">6</span> <span class="token operator">-&gt;</span> <span class="token constant">NULL</span>
<span class="token number">2</span> <span class="token operator">-&gt;</span> <span class="token number">6</span> <span class="token operator">-&gt;</span> <span class="token constant">NULL</span>
<span class="token number">8</span> <span class="token operator">-&gt;</span> <span class="token number">2</span> <span class="token operator">-&gt;</span> <span class="token number">6</span> <span class="token operator">-&gt;</span> <span class="token constant">NULL</span>
<span class="token number">3</span> <span class="token operator">-&gt;</span> <span class="token number">8</span> <span class="token operator">-&gt;</span> <span class="token number">2</span> <span class="token operator">-&gt;</span> <span class="token number">6</span> <span class="token operator">-&gt;</span> <span class="token constant">NULL</span>
<span class="token number">1</span> <span class="token operator">-&gt;</span> <span class="token number">3</span> <span class="token operator">-&gt;</span> <span class="token number">8</span> <span class="token operator">-&gt;</span> <span class="token number">2</span> <span class="token operator">-&gt;</span> <span class="token number">6</span> <span class="token operator">-&gt;</span> <span class="token constant">NULL</span>
</code></pre>
<ul>
<li>这样，我们就能更加进一步的确保我们实现 <strong>头插法</strong> 这个算法的正确性了。</li>
</ul>
<hr>
<blockquote>
<p>验证算法的正确性有两个有效的办法：<br>  <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span> 构造大量的 <strong>测试数据</strong> 进行输入输出测试；<br>  <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mn>2</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">2</span><span class="mclose">)</span></span></span></span></span> 打印每一个操作后，数据结构的 <strong>当前状态</strong>，看是否和预期相符；</p>
</blockquote>
<ul>
<li>对 链表 进行打印，就是利用了这里的第 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mn>2</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">2</span><span class="mclose">)</span></span></span></span></span> 点，这个方法虽然原始，但是能够让你对每一步操作都了然于胸， 尤其是写到后面，代码量爆炸的时候，这个方法往往能够让你规避很多不必要的逻辑错误。</li>
</ul>
<h1><a id="_152"></a>五、链表元素的索引</h1>
<h2><a id="1_153"></a>1、算法描述</h2>
<blockquote>
<p>  给定一个链表头结点<code>head</code>，并且给定一个索引值 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mo stretchy="false">(</mo><mi>i</mi><mo>≥</mo><mn>0</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">i (i \ge 0)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault">i</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">0</span><span class="mclose">)</span></span></span></span></span>，求这个链表的第 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.65952em; vertical-align: 0em;"></span><span class="mord mathdefault">i</span></span></span></span></span> 个结点（为了和 C语言 的数组下标保持一致，我们假定链表头结点代表第 0 个结点）。</p>
</blockquote>
<ul>
<li>这实际上是一个 <strong>遍历链表</strong> 的过程，我们先来看下动画演示。</li>
</ul>
<h2><a id="2_156"></a>2、动画演示</h2>
<p><img src="https://img-blog.csdnimg.cn/d529111c57c74ec5a5992856881cbf03.gif#pic_center" alt=""></p>
<blockquote>
<p>上图演示的是通过遍历，索引到第 3 个结点（下标从 0 开始计数）的过程，其中：<br>  <font color="red"><b>head</b></font> 代表链表头结点；<br>  <font color="red"><b>tail</b></font> 代表链表尾结点；<br>  <font color="red"><b>j / temp</b></font> 代表当前枚举到的第 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi><mo stretchy="false">(</mo><mi>j</mi><mo>≥</mo><mn>0</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">j (j \ge 0)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.05724em;">j</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right: 0.05724em;">j</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">0</span><span class="mclose">)</span></span></span></span></span>个结点，即动图中的 <font color="fe8a27"><b>橙色实心结点</b></font>；</p>
</blockquote>
<h2><a id="3_159"></a>3、源码详解</h2>
<pre><code class="prism language-c">ListNode <span class="token operator">*</span><span class="token function">ListGetNode</span><span class="token punctuation">(</span>ListNode <span class="token operator">*</span>head<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    ListNode <span class="token operator">*</span>temp <span class="token operator">=</span> head<span class="token punctuation">;</span>       <span class="token comment">// (1) </span>
    <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                   <span class="token comment">// (2) </span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>temp <span class="token operator">&amp;&amp;</span> j <span class="token operator">&lt;</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token comment">// (3) </span>
        temp <span class="token operator">=</span> temp<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>       <span class="token comment">// (4) </span>
        <span class="token operator">++</span>j<span class="token punctuation">;</span>                     <span class="token comment">// (5) </span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>temp <span class="token operator">||</span> j <span class="token operator">&gt;</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>             <span class="token comment">// (6) </span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> temp<span class="token punctuation">;</span>                 <span class="token comment">// (7) </span>
<span class="token punctuation">}</span>
</code></pre>
<ul>
<li><span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span> <code>temp</code>代表从链表头开始的 <strong>游标指针</strong>，用于对链表进行 <strong>遍历</strong> 操作；</li>
<li><span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mn>2</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">2</span><span class="mclose">)</span></span></span></span></span> <code>j</code>代表当前访问到了第 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.85396em; vertical-align: -0.19444em;"></span><span class="mord mathdefault" style="margin-right: 0.05724em;">j</span></span></span></span></span> 个结点；</li>
<li><span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mn>3</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">3</span><span class="mclose">)</span></span></span></span></span> 如果 <strong>游标指针</strong> 非空，并且<code>j &lt; i</code>，则代表还没访问到目标结点，继续执行循环；</li>
<li><span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mn>4</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(4)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">4</span><span class="mclose">)</span></span></span></span></span> 将 <strong>游标指针</strong> 的 <strong>后继结点</strong> 作为新一轮的 <strong>游标指针</strong>，继续迭代；</li>
<li><span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mn>5</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(5)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">5</span><span class="mclose">)</span></span></span></span></span> <code>j</code>自增，等价于<code>j = j + 1;</code></li>
<li><span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mn>6</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(6)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">6</span><span class="mclose">)</span></span></span></span></span> 当 <strong>游标指针</strong> 为空，或者<code>j &gt; i</code>，则说明给定的<code>i</code>超过了链表长度，返回 <strong>空结点</strong>；</li>
<li><span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mn>7</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(7)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">7</span><span class="mclose">)</span></span></span></span></span> 最后，返回找到的第<code>i</code>个结点；</li>
</ul>
<h2><a id="4_181"></a>4、测试用例</h2>
<pre><code class="prism language-c"><span class="token keyword">void</span> <span class="token function">testListGetNode</span><span class="token punctuation">(</span>ListNode <span class="token operator">*</span>head<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> i<span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">7</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        ListNode <span class="token operator">*</span>node <span class="token operator">=</span> <span class="token function">ListGetNode</span><span class="token punctuation">(</span>head<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>node<span class="token punctuation">)</span>
            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"index(%d) is out of range.\n"</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">else</span> 
            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"node(%d) is %d.\n"</span><span class="token punctuation">,</span> i<span class="token punctuation">,</span> node<span class="token operator">-&gt;</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>    
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    
    <span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    ListNode <span class="token operator">*</span>head <span class="token operator">=</span> <span class="token function">ListCreateListByHead</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// (1)</span>
    <span class="token function">testListGetNode</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span><span class="token punctuation">;</span>                         <span class="token comment">// (2)</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<ul>
<li>这个测试用例，首先第 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span> 步，利用 <strong>头插法</strong> 对给定数组创建了一个链表；然后第 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mn>2</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">2</span><span class="mclose">)</span></span></span></span></span> 步，枚举 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mo>∈</mo><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mn>6</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">i \in [0, 6]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.69862em; vertical-align: -0.0391em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord">6</span><span class="mclose">]</span></span></span></span></span>，分别去取链表的第 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.65952em; vertical-align: 0em;"></span><span class="mord mathdefault">i</span></span></span></span></span> 个结点，运行结果如下：</li>
</ul>
<pre><code class="prism language-c"><span class="token function">node</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> is <span class="token number">1.</span>
<span class="token function">node</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> is <span class="token number">3.</span>
<span class="token function">node</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span> is <span class="token number">8.</span>
<span class="token function">node</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span> is <span class="token number">2.</span>
<span class="token function">node</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span> is <span class="token number">6.</span>
<span class="token function">index</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span> is out of range<span class="token punctuation">.</span>
<span class="token function">index</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span> is out of range<span class="token punctuation">.</span>
</code></pre>
<ul>
<li>这表明当下标在链表元素个数范围内时，能够找到对应结点；否则，返回的是空节点；进一步验证了程序实现的正确性。</li>
</ul>
<h2><a id="5_211"></a>5、算法分析</h2>
<h3><a id="1_212"></a>1）时间复杂度</h3>
<ul>
<li>索引结点的操作，最坏情况下需要遍历整个链表，所以时间复杂度为 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></span>。</li>
</ul>
<h3><a id="2_214"></a>2）空间复杂度</h3>
<ul>
<li>整个索引过程只记录了两个变量：<strong>游标结点</strong> 和 <strong>当前索引值</strong>。和链表长度无关，所以空间复杂度为 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span>。</li>
</ul>
<h1><a id="_216"></a>六、链表元素的查找</h1>
<h2><a id="1_217"></a>1、算法描述</h2>
<blockquote>
<p>  给定一个链表头<code>head</code>，并且给定一个值 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault" style="margin-right: 0.03588em;">v</span></span></span></span></span>，查找出这个链表上 <strong>数据域</strong> 等于 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault" style="margin-right: 0.03588em;">v</span></span></span></span></span> 的第一个结点。</p>
</blockquote>
<ul>
<li>查找的过程，基本和索引类似，也是对链表的遍历操作，首先请看动画演示。</li>
</ul>
<h2><a id="2_220"></a>2、动画演示</h2>
<p><img src="https://img-blog.csdnimg.cn/d529111c57c74ec5a5992856881cbf03.gif#pic_center" alt=""></p>
<blockquote>
<p>上图演示的是通过遍历，查找到值为 2 的结点的过程，其中：<br>  <font color="red"><b>head</b></font> 代表链表头结点；<br>  <font color="red"><b>tail</b></font> 代表链表尾结点；<br>  <font color="red"><b>j / temp</b></font> 代表当前枚举到的第 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi><mo stretchy="false">(</mo><mi>j</mi><mo>≥</mo><mn>0</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">j (j \ge 0)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.05724em;">j</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right: 0.05724em;">j</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">0</span><span class="mclose">)</span></span></span></span></span>个结点，即动图中的 <font color="fe8a27"><b>橙色实心结点</b></font>；</p>
</blockquote>
<h2><a id="3_223"></a>3、源码详解</h2>
<pre><code class="prism language-c">ListNode <span class="token operator">*</span><span class="token function">ListFindNodeByValue</span><span class="token punctuation">(</span>ListNode <span class="token operator">*</span>head<span class="token punctuation">,</span> DataType v<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    ListNode <span class="token operator">*</span>temp <span class="token operator">=</span> head<span class="token punctuation">;</span>       <span class="token comment">// (1) </span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>temp<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment">// (2) </span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>temp<span class="token operator">-&gt;</span>data <span class="token operator">==</span> v<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> temp<span class="token punctuation">;</span>         <span class="token comment">// (3) </span>
        <span class="token punctuation">}</span> 
        temp <span class="token operator">=</span> temp<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>       <span class="token comment">// (4) </span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>                 <span class="token comment">// (5) </span>
<span class="token punctuation">}</span>
</code></pre>
<ul>
<li><span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span> <code>temp</code>代表从 <strong>链表头</strong> 开始遍历的 <strong>游标指针</strong>；</li>
<li><span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mn>2</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">2</span><span class="mclose">)</span></span></span></span></span> 如果 <strong>游标指针</strong> 非空，继续循环 ；</li>
<li><span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mn>3</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">3</span><span class="mclose">)</span></span></span></span></span> 一旦发现 <strong>数据域</strong> 和 给定的 参数<code>v</code>相等，立即返回该结点对应的指针；</li>
<li><span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mn>4</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(4)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">4</span><span class="mclose">)</span></span></span></span></span> 否则，将 <strong>游标指针</strong> 的 <strong>后继结点</strong> 作为新一轮的 <strong>游标指针</strong>，继续迭代；</li>
<li><span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mn>5</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(5)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">5</span><span class="mclose">)</span></span></span></span></span> 一直到链表尾都找不到，返回 NULL；</li>
</ul>
<h2><a id="4_242"></a>4、测试用例</h2>
<pre><code class="prism language-c"><span class="token keyword">void</span> <span class="token function">testListFindNodeByValue</span><span class="token punctuation">(</span>ListNode <span class="token operator">*</span>head<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> i<span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">6</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span> 
        ListNode <span class="token operator">*</span>node <span class="token operator">=</span> <span class="token function">ListFindNodeByValue</span><span class="token punctuation">(</span>head<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span> 
        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>node<span class="token punctuation">)</span>
            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"value(%d) is not found!\n"</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">else</span> 
            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"value(%d) is found!\n"</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>    
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    
    <span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    ListNode <span class="token operator">*</span>head <span class="token operator">=</span> <span class="token function">ListCreateListByHead</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span>   
    <span class="token function">testListFindNodeByValue</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<ul>
<li>这个测试用例，就是选择了 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mn>1</mn><mo separator="true">,</mo><mn>6</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[1, 6]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord">6</span><span class="mclose">]</span></span></span></span></span> 这六个数，然后依次利用<code>ListFindNodeByValue</code>去链表中查找，运行结果如下：</li>
</ul>
<pre><code class="prism language-c"><span class="token function">value</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> is found<span class="token operator">!</span>
<span class="token function">value</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span> is found<span class="token operator">!</span>
<span class="token function">value</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span> is found<span class="token operator">!</span>
<span class="token function">value</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span> is not found<span class="token operator">!</span>
<span class="token function">value</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span> is not found<span class="token operator">!</span>
<span class="token function">value</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span> is found<span class="token operator">!</span>
</code></pre>
<h2><a id="5_270"></a>5、算法分析</h2>
<h3><a id="1_271"></a>1）时间复杂度</h3>
<ul>
<li>查找结点的操作，最坏情况下就是找不到，需要遍历整个链表，所以时间复杂度为 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></span>。</li>
</ul>
<h3><a id="2_273"></a>2）空间复杂度</h3>
<ul>
<li>整个查找过程只记录了一个变量：游标指针。和链表长度无关，所以空间复杂度为 O(1)。</li>
</ul>
<h1><a id="_275"></a>七、链表结点的插入</h1>
<h2><a id="1_276"></a>1、算法描述</h2>
<blockquote>
<p>  给定一个链表头<code>head</code>，并且给定一个位置 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mo stretchy="false">(</mo><mi>i</mi><mo>≥</mo><mn>0</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">i(i \ge 0)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault">i</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">0</span><span class="mclose">)</span></span></span></span></span> 和 一个值 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault" style="margin-right: 0.03588em;">v</span></span></span></span></span>，求生成一个值为 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault" style="margin-right: 0.03588em;">v</span></span></span></span></span> 的结点，并且将它插入到 链表 第 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.65952em; vertical-align: 0em;"></span><span class="mord mathdefault">i</span></span></span></span></span> 个结点之后。</p>
</blockquote>
<ul>
<li>首先，我们需要找到第 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.65952em; vertical-align: 0em;"></span><span class="mord mathdefault">i</span></span></span></span></span> 个位置，可以利用上文提到的 <strong>链表结点的索引</strong>；然后，再执行插入操作，而插入操作分为两步：第一步就是 <strong>创建结点</strong> 的过程；第二步，是断开之前第 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.65952em; vertical-align: 0em;"></span><span class="mord mathdefault">i</span></span></span></span></span> 个结点 和 第 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">i+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.74285em; vertical-align: -0.08333em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">1</span></span></span></span></span> 个结点之间的 “链”，并且将创建出来的结点 “链接” 到两者之间。来看下动图演示。</li>
</ul>
<h2><a id="2_279"></a>2、动画演示</h2>
<p><img src="https://img-blog.csdnimg.cn/917287ac0fce4e34aa6b5277f861009d.gif#pic_center" alt=""></p>
<blockquote>
<p>上图演示的是通过遍历，将数据为 8 的结点插入到链表第 1 个（下标从 0 开始）结点后的过程，其中：<br>  <font color="red"><b>head</b></font> 代表链表头结点；<br>  <font color="red"><b>tail</b></font> 代表链表尾结点；<br>  <font color="red"><b>pre</b></font> 代表待插入结点的 <strong>前驱结点</strong>，也是 <strong>游标指针</strong> 指代的结点，即动图中的 <font color="fe8c2a"><b>橙色实心结点</b></font>；<br>  <font color="red"><b>aft</b></font> 代表 <strong>待插入结点</strong> 的 <strong>后继结点</strong>，即动图中的 <font color="2ebbd1"><b>蓝色实心结点</b></font>；<br>  <font color="red"><b>vtx</b></font> 代表将要插入的结点，即动图中的 <font color="52bc69"><b>绿色实心结点</b></font>；</p>
</blockquote>
<h2><a id="3_282"></a>3、源码详解</h2>
<pre><code class="prism language-c">ListNode <span class="token operator">*</span><span class="token function">ListInsertNode</span><span class="token punctuation">(</span>ListNode <span class="token operator">*</span>head<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> DataType v<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    ListNode <span class="token operator">*</span>pre<span class="token punctuation">,</span> <span class="token operator">*</span>vtx<span class="token punctuation">,</span> <span class="token operator">*</span>aft<span class="token punctuation">;</span>                     <span class="token comment">// (1) </span>
    <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                                     <span class="token comment">// (2) </span>
    pre <span class="token operator">=</span> head<span class="token punctuation">;</span>                                    <span class="token comment">// (3) </span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>pre <span class="token operator">&amp;&amp;</span> j <span class="token operator">&lt;</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>                          <span class="token comment">// (4) </span>
        pre <span class="token operator">=</span> pre<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>                           <span class="token comment">// (5) </span>
        <span class="token operator">++</span>j<span class="token punctuation">;</span>                                       <span class="token comment">// (6) </span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>pre<span class="token punctuation">)</span> <span class="token punctuation">{</span> 
        <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>                               <span class="token comment">// (7) </span>
    <span class="token punctuation">}</span>
    vtx <span class="token operator">=</span> <span class="token function">ListCreateNode</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>                       <span class="token comment">// (8) </span>
    aft <span class="token operator">=</span> pre<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>                               <span class="token comment">// (9)</span>
    vtx<span class="token operator">-&gt;</span>next <span class="token operator">=</span> aft<span class="token punctuation">;</span>                               <span class="token comment">// (10)</span>
    pre<span class="token operator">-&gt;</span>next <span class="token operator">=</span> vtx<span class="token punctuation">;</span>                               <span class="token comment">// (11)</span>
    <span class="token keyword">return</span> vtx<span class="token punctuation">;</span>                                    <span class="token comment">// (12)  </span>
<span class="token punctuation">}</span>
</code></pre>
<ul>
<li><span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span> 预先定义三个指针，当结点插入完毕后，  <code>pre -&gt; vtx -&gt; aft</code>；</li>
<li><span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mn>2</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">2</span><span class="mclose">)</span></span></span></span></span> 定义一个计数器，当 <code>j == i</code>时，表明找到要插入的位置；</li>
<li><span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mn>3</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">3</span><span class="mclose">)</span></span></span></span></span> 从 <strong>链表头结点</strong> 开始迭代遍历链表；</li>
<li><span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mn>4</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(4)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">4</span><span class="mclose">)</span></span></span></span></span> 如果还没有到链表尾，或者没有找到插入位置则继续循环；</li>
<li><span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mn>5</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(5)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">5</span><span class="mclose">)</span></span></span></span></span> 将 <strong>游标指针</strong> 的 <strong>后继结点</strong> 作为新一轮的 <strong>游标指针</strong>，继续迭代；</li>
<li><span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mn>6</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(6)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">6</span><span class="mclose">)</span></span></span></span></span> 计数器加 1；</li>
<li><span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mn>7</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(7)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">7</span><span class="mclose">)</span></span></span></span></span> 元素个数不足，无法找到给定位置，返回 NULL；</li>
<li><span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mn>8</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(8)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">8</span><span class="mclose">)</span></span></span></span></span> 创建一个值为<code>v</code>的 <strong>孤立结点</strong>；</li>
<li><span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mn>9</mn><mo stretchy="false">)</mo><mo>→</mo><mo stretchy="false">(</mo><mn>11</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(9) \to (11)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">9</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span> 这三步就是为了将<code>vtx</code>插入到<code>pre -&gt; aft</code>之间，插入完毕后<code>pre -&gt; vtx -&gt; aft</code>。</li>
<li><span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mn>12</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(12)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mord">2</span><span class="mclose">)</span></span></span></span></span> 最后，返回插入的那个结点；</li>
</ul>
<h2><a id="4_312"></a>4、测试用例</h2>
<pre><code class="prism language-c"><span class="token keyword">void</span> <span class="token function">testListInsertNode</span><span class="token punctuation">(</span>ListNode <span class="token operator">*</span>head<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">ListPrint</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">ListInsertNode</span><span class="token punctuation">(</span>head<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">ListPrint</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    
    <span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    ListNode <span class="token operator">*</span>head <span class="token operator">=</span> <span class="token function">ListCreateListByHead</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">testListInsertNode</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<ul>
<li>这个测试用例，就是在原链表<code>1 -&gt; 3 -&gt; 2 -&gt; 6</code>的基础上，在第 1 个结点（0 - based）的后面插入一个值为 8 的结点，并且返回这个结点。这个例子的运行结果如下：</li>
</ul>
<pre><code class="prism language-c"><span class="token number">1</span> <span class="token operator">-&gt;</span> <span class="token number">3</span> <span class="token operator">-&gt;</span> <span class="token number">2</span> <span class="token operator">-&gt;</span> <span class="token number">6</span> <span class="token operator">-&gt;</span> <span class="token constant">NULL</span>
执行插入操作！
<span class="token number">1</span> <span class="token operator">-&gt;</span> <span class="token number">3</span> <span class="token operator">-&gt;</span> <span class="token number">8</span> <span class="token operator">-&gt;</span> <span class="token number">2</span> <span class="token operator">-&gt;</span> <span class="token number">6</span> <span class="token operator">-&gt;</span> <span class="token constant">NULL</span>
</code></pre>
<h2><a id="5_333"></a>5、算法分析</h2>
<h3><a id="1_334"></a>1）时间复杂度</h3>
<ul>
<li>虽然插入操作本身是 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span> 的，但是这里有一步 <strong>索引结点</strong> 的操作，最坏情况下就是找不到对应的结点，需要遍历整个链表，所以时间复杂度为 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></span>。</li>
</ul>
<h3><a id="2_336"></a>2）空间复杂度</h3>
<ul>
<li>整个查找和插入的过程只记录了三个变量，和链表长度无关，所以空间复杂度为 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span>。</li>
</ul>
<h1><a id="_338"></a>八、链表结点的删除</h1>
<h2><a id="1_339"></a>1、算法描述</h2>
<blockquote>
<p>  给定一个链表头<code>head</code>，并且给定一个位置 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mo stretchy="false">(</mo><mi>i</mi><mo>≥</mo><mn>0</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">i(i \ge 0)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault">i</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">0</span><span class="mclose">)</span></span></span></span></span>，将位置为 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.65952em; vertical-align: 0em;"></span><span class="mord mathdefault">i</span></span></span></span></span> 的结点删除，并且返回新链表的头结点（为什么要返回头结点？因为被删掉的有可能是原来的头结点）。</p>
</blockquote>
<ul>
<li>链表结点的删除问题可以分为三种情况进行讨论，如下：<br>
<img src="https://img-blog.csdnimg.cn/9e3ce821cbba4470a4f9358e28467161.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1doZXJlSXNIZXJvRnJvbQ==,size_16,color_FFFFFF,t_70#pic_center" alt=""></li>
<li><span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span> 空链表：无法进行删除，直接返回 空结点；</li>
<li><span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mn>2</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">2</span><span class="mclose">)</span></span></span></span></span> 非空链表删除头结点：缓存下 <strong>头结点</strong> 的 <strong>后继结点</strong>，释放 <strong>头结点</strong> 内存，再返回这个 <strong>后继结点</strong>；</li>
<li><span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mn>3</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">3</span><span class="mclose">)</span></span></span></span></span> 非空链表删除非头结点：通过遍历，找到 <strong>需要删除结点</strong> 的 <strong>前驱结点</strong>，如果 <strong>需要删除结点</strong> 自身为 空，则返回 <strong>链表头结点</strong>；否则，缓存 <strong>需要删除结点</strong> 以及它的 <strong>后继结点</strong>，将 <strong>前驱结点</strong> 指向 <strong>后继结点</strong>，然后再释放 <strong>需要删除结点</strong> 的内存，返回 <strong>链表头结点</strong>；</li>
</ul>
<hr>
<h2><a id="2_348"></a>2、动画演示</h2>
<p><img src="https://img-blog.csdnimg.cn/8b1a9cbe2b234701affb140b6930f58a.gif#pic_center" alt=""></p>
<blockquote>
<p>上图演示的是通过遍历，将第 2 号结点（下标从 0 开始）删除的过程，其中：<br>  <font color="red"><b>head</b></font> 代表链表头结点；<br>  <font color="red"><b>tail</b></font> 代表链表尾结点；<br>  <font color="red"><b>pre</b></font> 代表待删除结点的前驱结点，也是游走指针指代的结点，即动图中的 <font color="fe8c2a"><b>橙色实心结点</b></font>；<br>  <font color="red"><b>aft</b></font> 代表待删除结点的后继结点，即动图中的 <font color="52bc69"><b>绿色实心结点</b></font>；<br>  <font color="red"><b>del</b></font> 代表将要删除的结点，即动图中的 <font color="d9513c"><b>红色实心结点</b></font>；</p>
</blockquote>
<h2><a id="3_351"></a>3、源码详解</h2>
<pre><code class="prism language-c">ListNode <span class="token operator">*</span><span class="token function">ListDeleteNode</span><span class="token punctuation">(</span>ListNode <span class="token operator">*</span>head<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    ListNode <span class="token operator">*</span>pre<span class="token punctuation">,</span> <span class="token operator">*</span>del<span class="token punctuation">,</span> <span class="token operator">*</span>aft<span class="token punctuation">;</span>
    <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>head <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>              <span class="token comment">// (1)  </span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                  <span class="token comment">// (2) </span>
        del <span class="token operator">=</span> head<span class="token punctuation">;</span>               <span class="token comment">// (3)       </span>
        head <span class="token operator">=</span> head<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>        <span class="token comment">// (4)  </span>
        <span class="token function">free</span><span class="token punctuation">(</span>del<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">// (5) </span>
        <span class="token keyword">return</span> head<span class="token punctuation">;</span>              <span class="token comment">// (6)  </span>
    <span class="token punctuation">}</span>
    
    pre <span class="token operator">=</span> head<span class="token punctuation">;</span>                   <span class="token comment">// (7)  </span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>pre <span class="token operator">&amp;&amp;</span> j <span class="token operator">&lt;</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token comment">// (8)  </span>
        pre <span class="token operator">=</span> pre<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
        <span class="token operator">++</span> j<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>pre <span class="token operator">||</span> <span class="token operator">!</span>pre<span class="token operator">-&gt;</span>next<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment">// (9) </span>
        <span class="token keyword">return</span> head<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    del <span class="token operator">=</span> pre<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>              <span class="token comment">// (10) </span>
    aft <span class="token operator">=</span> del<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>              <span class="token comment">// (11) </span>
    pre<span class="token operator">-&gt;</span>next <span class="token operator">=</span> aft<span class="token punctuation">;</span>              <span class="token comment">// (12) </span>
    <span class="token function">free</span><span class="token punctuation">(</span>del<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment">// (13) </span>
    <span class="token keyword">return</span> head<span class="token punctuation">;</span>                  <span class="token comment">// (14) </span>
<span class="token punctuation">}</span> 
</code></pre>
<ul>
<li><span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span> 空链表，无法执行删除，直接返回；</li>
<li><span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mn>2</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">2</span><span class="mclose">)</span></span></span></span></span> 需要删除链表第 0 个结点；</li>
<li><span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mn>3</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">3</span><span class="mclose">)</span></span></span></span></span> 缓存第 0 个结点；</li>
<li><span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mn>4</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(4)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">4</span><span class="mclose">)</span></span></span></span></span> 将新的 <strong>链表头结点</strong> 变为 <strong>当前头结点</strong> 的 <strong>后继结点</strong>；</li>
<li><span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mn>5</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(5)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">5</span><span class="mclose">)</span></span></span></span></span> 调用系统库函数<code>free</code>释放内存；</li>
<li><span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mn>6</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(6)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">6</span><span class="mclose">)</span></span></span></span></span> 返回新的 <strong>链表头结点</strong>；</li>
<li><span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mn>7</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(7)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">7</span><span class="mclose">)</span></span></span></span></span> 从 <strong>链表头结点</strong> 开始遍历链表；</li>
<li><span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mn>8</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(8)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">8</span><span class="mclose">)</span></span></span></span></span> 找到将要被删除结点的 <strong>前驱结点</strong><code>pre</code>；</li>
<li><span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mn>9</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(9)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">9</span><span class="mclose">)</span></span></span></span></span> 如果 <strong>前驱结点</strong> 为空，或者 <strong>需要删除的结点</strong> 为空，则直接返回当前 <strong>链表头结点</strong>；</li>
<li><span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mn>10</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(10)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mord">0</span><span class="mclose">)</span></span></span></span></span> 缓存需要删除的结点到<code>del</code>；</li>
<li><span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mn>11</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(11)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span> 缓存需要删除结点的<strong>后继结点</strong>到<code>aft</code>；</li>
<li><span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mn>12</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(12)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mord">2</span><span class="mclose">)</span></span></span></span></span> 将需要删除的结点的<strong>前驱结点</strong>指向它的<strong>后继结点</strong>；</li>
<li><span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mn>13</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(13)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mord">3</span><span class="mclose">)</span></span></span></span></span> 释放需要删除结点的内存空间；</li>
<li><span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mn>14</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(14)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mord">4</span><span class="mclose">)</span></span></span></span></span> 返回链表头结点；</li>
</ul>
<h2><a id="4_395"></a>4、测试用例</h2>
<pre><code class="prism language-c"><span class="token keyword">void</span> <span class="token function">testListDeleteNode</span><span class="token punctuation">(</span>ListNode <span class="token operator">*</span>head<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">ListPrint</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"执行 2 号结点删除操作！\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
    head <span class="token operator">=</span> <span class="token function">ListDeleteNode</span><span class="token punctuation">(</span>head<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">ListPrint</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"执行 0 号结点删除操作！\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
    head <span class="token operator">=</span> <span class="token function">ListDeleteNode</span><span class="token punctuation">(</span>head<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">ListPrint</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    
    <span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    ListNode <span class="token operator">*</span>head <span class="token operator">=</span> <span class="token function">ListCreateListByHead</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// (1)</span>
    <span class="token function">testListDeleteNode</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span><span class="token punctuation">;</span>                      <span class="token comment">// (2)</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<ul>
<li>这个用例的第 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span> 步通过 <strong>头插法</strong> 创建了一个 <code>1 -&gt; 3 -&gt; 8 -&gt; 2 -&gt; 6</code>的链表， 然后将 2 号结点删除，再将 头结点删除，运行结果如下：</li>
</ul>
<pre><code class="prism language-c"><span class="token number">1</span> <span class="token operator">-&gt;</span> <span class="token number">3</span> <span class="token operator">-&gt;</span> <span class="token number">8</span> <span class="token operator">-&gt;</span> <span class="token number">2</span> <span class="token operator">-&gt;</span> <span class="token number">6</span> <span class="token operator">-&gt;</span> <span class="token constant">NULL</span>
执行 <span class="token number">2</span> 号结点删除操作！
<span class="token number">1</span> <span class="token operator">-&gt;</span> <span class="token number">3</span> <span class="token operator">-&gt;</span> <span class="token number">2</span> <span class="token operator">-&gt;</span> <span class="token number">6</span> <span class="token operator">-&gt;</span> <span class="token constant">NULL</span>
执行 <span class="token number">0</span> 号结点删除操作！
<span class="token number">3</span> <span class="token operator">-&gt;</span> <span class="token number">2</span> <span class="token operator">-&gt;</span> <span class="token number">6</span> <span class="token operator">-&gt;</span> <span class="token constant">NULL</span>
</code></pre>
<h2><a id="5_423"></a>5、算法分析</h2>
<h3><a id="1_424"></a>1）时间复杂度</h3>
<ul>
<li>删除结点本身的时间复杂度为 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span>。</li>
<li>但是由于需要查找到需要删除的结点，所以总的时间复杂度还是 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></span> 的。</li>
</ul>
<h3><a id="2_427"></a>2）空间复杂度</h3>
<ul>
<li>不需要用到额外空间，所以总的时间复杂度为 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span>。</li>
</ul>
<h1><a id="_429"></a>九、链表的销毁</h1>
<h2><a id="1_430"></a>1、算法描述</h2>
<blockquote>
<p>  链表的销毁，就是需要将 <strong>所有结点</strong> 的内存空间进行释放，并且需要将 <strong>链表的头结点</strong> 置空。</p>
</blockquote>
<ul>
<li>链表的销毁，可以理解成不断删除第 0 号结点的过程，直到链表头为空位置，只是一个循环调用，这里就不多做介绍，有兴趣的朋友可以自行实现一下。</li>
</ul>
<h2><a id="2_433"></a>2、动画演示</h2>
<p><img src="https://img-blog.csdnimg.cn/03ee8229c9e64a7180b2f4ee221f03ea.gif#pic_center" alt=""></p>
<blockquote>
<p>上图所示的是 <strong>链表销毁</strong> 的整个插入过程，其中：<br>  <font color="red"><b>head</b></font> 代表链表头结点，即动图中的 <font color="52bc69"><b>绿色结点</b></font>，每删除一个结点，<strong>头结点</strong> 就变成了之前头结点的 <strong>后继结点</strong>；<br>  <font color="red"><b>tail</b></font> 代表链表尾结点；<br>  <font color="red"><b>temp</b></font> 代表 <strong>待删除结点</strong>，即动图中的 <font color="fe8a27"><b>橙色结点</b></font>，执行删除后，它的内存空间就释放了；</p>
</blockquote>
<h2><a id="3_436"></a>3、源码详解</h2>
<pre><code class="prism language-c"><span class="token keyword">void</span> <span class="token function">ListDestroyList</span><span class="token punctuation">(</span>ListNode <span class="token operator">*</span><span class="token operator">*</span>pHead<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// (1) </span>
    ListNode <span class="token operator">*</span>head <span class="token operator">=</span> <span class="token operator">*</span>pHead<span class="token punctuation">;</span>             <span class="token comment">// (2) </span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        <span class="token comment">// (3) </span>
        head <span class="token operator">=</span> <span class="token function">ListDeleteNode</span><span class="token punctuation">(</span>head<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// (4) </span>
    <span class="token punctuation">}</span>
    <span class="token operator">*</span>pHead <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>                       <span class="token comment">// (5) </span>
<span class="token punctuation">}</span>
</code></pre>
<ul>
<li><span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span> 这里必须用二级指针，因为删除后需要将链表头置空，普通的指针传参无法影响外部指针变量；</li>
<li><span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mn>2</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">2</span><span class="mclose">)</span></span></span></span></span> 给 <strong>链表头结点</strong> 解引用，即通过 <strong>链表头结点的地址</strong> 获取 <strong>链表头结点</strong>；</li>
<li><span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mn>3</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">3</span><span class="mclose">)</span></span></span></span></span> 如果链表非空，则继续循环；</li>
<li><span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mn>4</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(4)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">4</span><span class="mclose">)</span></span></span></span></span> 每次迭代，删除 <strong>链表头结点</strong>，并且返回其 <strong>后继结点</strong> 作为新的 <strong>链表头结点</strong>；</li>
<li><span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mn>5</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(5)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">5</span><span class="mclose">)</span></span></span></span></span> 最后，将 <strong>链表头结点</strong> 置空，这样当函数返回时，传参的<code>head</code>才能是<code>NULL</code>，否则外部会得到一个内存已经释放了的 <strong>野指针</strong>；</li>
</ul>
<h2><a id="4_451"></a>4、测试用例</h2>
<pre><code class="prism language-c"><span class="token keyword">void</span> <span class="token function">ListDestroyList</span><span class="token punctuation">(</span>ListNode <span class="token operator">*</span><span class="token operator">*</span>pHead<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    ListNode <span class="token operator">*</span>head <span class="token operator">=</span> <span class="token operator">*</span>pHead<span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        head <span class="token operator">=</span> <span class="token function">ListDeleteNode</span><span class="token punctuation">(</span>head<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token operator">*</span>pHead <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">void</span> <span class="token function">testListDestroyList</span><span class="token punctuation">(</span>ListNode <span class="token operator">*</span><span class="token operator">*</span>head<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">ListPrint</span><span class="token punctuation">(</span><span class="token operator">*</span>head<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">ListDestroyList</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span><span class="token punctuation">;</span> 
    <span class="token function">ListPrint</span><span class="token punctuation">(</span><span class="token operator">*</span>head<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    
    <span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    ListNode <span class="token operator">*</span>head <span class="token operator">=</span> <span class="token function">ListCreateListByHead</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">testListDestroyList</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>head<span class="token punctuation">)</span><span class="token punctuation">;</span> 
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<ul>
<li>测试用例主要是先创建了一个链表，然后通过不断删除 <strong>链表头结点</strong>，并且打印当前链表的过程，所以运行结果中我们可以看到整个链表的删除过程，当所有结点都被删除以后，<code>head</code>变为<code>NULL</code>。</li>
</ul>
<pre><code class="prism language-c"><span class="token number">1</span> <span class="token operator">-&gt;</span> <span class="token number">3</span> <span class="token operator">-&gt;</span> <span class="token number">8</span> <span class="token operator">-&gt;</span> <span class="token number">2</span> <span class="token operator">-&gt;</span> <span class="token number">6</span> <span class="token operator">-&gt;</span> <span class="token constant">NULL</span>
<span class="token number">3</span> <span class="token operator">-&gt;</span> <span class="token number">8</span> <span class="token operator">-&gt;</span> <span class="token number">2</span> <span class="token operator">-&gt;</span> <span class="token number">6</span> <span class="token operator">-&gt;</span> <span class="token constant">NULL</span>
<span class="token number">8</span> <span class="token operator">-&gt;</span> <span class="token number">2</span> <span class="token operator">-&gt;</span> <span class="token number">6</span> <span class="token operator">-&gt;</span> <span class="token constant">NULL</span>
<span class="token number">2</span> <span class="token operator">-&gt;</span> <span class="token number">6</span> <span class="token operator">-&gt;</span> <span class="token constant">NULL</span>
<span class="token number">6</span> <span class="token operator">-&gt;</span> <span class="token constant">NULL</span>
<span class="token constant">NULL</span>
<span class="token constant">NULL</span>
</code></pre>
<h2><a id="5_483"></a>5、算法分析</h2>
<h3><a id="1_484"></a>1）时间复杂度</h3>
<ul>
<li>删除链表头结点的过程，每次从头部开始删除，所以时间复杂度为 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span>。</li>
<li>总共遍历 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">n</span></span></span></span></span> 次删除，是乘法关系，所以总的时间复杂度是 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></span> 的。</li>
</ul>
<h3><a id="2_487"></a>2）空间复杂度</h3>
<ul>
<li>全程只需要一个 <strong>游标指针</strong> 用于遍历链表，和链表长度无关，所以总的时间复杂度为 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span>。</li>
</ul>
<h1><a id="_489"></a>十、链表的优缺点</h1>
<h2><a id="1_490"></a>1、优点</h2>
<blockquote>
<p><strong>内存分配</strong>：<br>  由于是链式存储，随时增加元素随时分配内存，不需要像数组那样进行预分配存储空间；<br><strong>插入</strong>：<br>  当拥有链表某个结点的指针时，在它 <strong>后继位置</strong> 插入一个新的结点的的时间复杂度为 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span>；<br><strong>删除</strong>：<br>  当拥有链表某个结点的指针时，删除它的 <strong>后继结点</strong> 的时间复杂度为 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span>；</p>
</blockquote>
<h2><a id="2_492"></a>2、缺点</h2>
<blockquote>
<p><strong>索引</strong>：<br>  索引第几个结点时，时间复杂度为 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></span>；<br><strong>查找</strong>：<br>  查找是否存在某个结点时，时间复杂度为 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></span>；</p>
</blockquote>
<hr>
<ul>
<li>关于 <font color="eb3f41"><b>「 单向链表 」</b></font> 的内容到这里就结束了。</li>
<li>有关<a href="https://blog.csdn.net/whereisherofrom/category_11227297.html"><font color="13ae01"><b>🌳《<u>画解数据结构</u>》🌳 </b></font></a>的源码均开源，链接如下：<a href="https://github.com/WhereIsHeroFrom/Code_Templates/tree/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%94%BB%E8%A7%A3%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">《画解数据结构》</a></li>
</ul>
<hr>
<center>👇🏻添加 博主 获取付费专栏优惠券👇🏻</center>
</div>
</body>

</html>
