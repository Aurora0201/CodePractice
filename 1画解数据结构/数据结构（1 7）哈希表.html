<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>《画解数据结构》三张动图，画解哈希</title>
  <link rel="stylesheet" href="https://stackedit.io/style.css" />
</head>

<body class="stackedit">
  <div class="stackedit__html"><center>本文已收录于专栏</center><center> <a href="https://blog.csdn.net/whereisherofrom/category_11227297.html"><font color="13ae01"><b>🌳《<u>画解数据结构</u>》🌳 </b></font></a> </center><br>
<h1><a id="_2"></a>零、前言</h1>
<p>  目前本专栏正在进行优惠活动，在博主主页添加博主好友（好友位没有满的话），可以获取 <font color="red"><strong>付费专栏优惠券</strong></font>。</p>
<blockquote>
<p>  <font color="FF4500"><b>「 数据结构 」</b></font> 和 <font color="FFa700"><b>「 算法 」</b></font> 是密不可分的，两者往往是<font color="ffd700"><b>「 相辅相成 」</b></font>的存在，所以，在学习 <font color="FF4500"><b>「 数据结构 」</b></font> 的过程中，不免会遇到各种<font color="FFa700"><b>「 算法 」</b></font>。<br>  数据结构 常用的操作一般为：<font color="13ae01"><b>「 增 」</b></font><font color="FF0500"><b>「 删 」</b></font><font color="ffd700"><b>「 改 」</b></font><font color="2290ff"><b>「 查 」</b></font>。基本上所有的数据结构都是围绕这几个操作进行展开的。<br>  那么这篇文章，作者将用 <font color="13ae01"><b>「 三张动图 」</b></font> 来阐述一种 <font color="FF4500"><b>「 均摊 O（1） 」</b></font> 的数据结构<br><br> </p><center><font size="5" color="2290ff"><b>「  哈希表 」</b></font></center><br>
<img src="https://img-blog.csdnimg.cn/4d1e51d74a194614a53e2960b58008b5.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1doZXJlSXNIZXJvRnJvbQ==,size_16,color_FFFFFF,t_70#pic_center" alt=""><p></p>
<center><b>🙉饭不食，水不饮，题必须刷🙉</b></center><br>
<center><font color="FFD700">C语言免费动漫教程，和我一起打卡！</font></center>
<center> <a href="https://blog.csdn.net/whereisherofrom/category_11131373.html"><font color="FFD700"><b>🌞《<u>光天化日学C语言</u>》🌞</b></font></a></center><br>
<center><font color="FF4500">LeetCode 太难？先看简单题！</font></center>
<center> <a href="https://blog.csdn.net/whereisherofrom/category_11158834.html"><font color="FF4500"><b>🧡《<u>C语言入门100例</u>》🧡</b></font></a></center><br>
<center><font color="13ae01">数据结构难？不存在的！</font></center>
<center> <a href="https://blog.csdn.net/whereisherofrom/category_11227297.html"><font color="13ae01"><b>🌳《<u>画解数据结构</u>》🌳 </b></font></a> </center><br>
<center><font color="2290ff">闭关刷 LeetCode，剑指大厂Offer！</font></center>
<center> <a href="https://docs.qq.com/mind/DU01SVGpab2tWdlNj"><font color="2290ff"><b>🌌《<u>LeetCode 刷题指引</u>》🌌</b></font></a></center><br>
<center><font color="886ce4">LeetCode 太简单？算法学起来！</font></center>
<center> <a href="https://blog.csdn.net/whereisherofrom/category_9273531.html"><font color="886ce4"><b>💜《<u>夜深人静写算法</u>》💜</b></font></a></center><br>
   哈希表常用的方法是 开放定址法 和 链地址法：
<p><img src="https://img-blog.csdnimg.cn/f07feb636e904adf814afb2f1eede981.gif#pic_center" alt=""></p><center><b>开放定址法</b></center><br>
<img src="https://img-blog.csdnimg.cn/3f3079ffb2404a89bf64cf9bdadb8153.gif#pic_center" alt=""><center><b>链地址法</b></center><br>
  看不懂没有关系，我会把它拆开来一个一个讲，首先来看一下今天要学习的内容目录。<p></p>
</blockquote>
<p></p><div class="toc"><h3>文章目录</h3><ul><li><a href="#_2">零、前言</a></li><li><a href="#_24">一、哈希表的概念</a></li><ul><li><a href="#1_25">1、查找算法</a></li><li><a href="#2_30">2、哈希表</a></li><li><a href="#2_40">2、哈希数组</a></li><li><a href="#3_44">3、关键字</a></li><li><a href="#4_54">4、哈希函数</a></li><li><a href="#5_61">5、哈希冲突</a></li><li><a href="#6_65">6、哈希地址</a></li></ul><li><a href="#_67">二、常用哈希函数</a></li><ul><li><a href="#1_68">1、直接定址法</a></li><li><a href="#2_78">2、平方取中法</a></li><li><a href="#3_82">3、折叠法</a></li><li><a href="#4_87">4、除留余数法</a></li><li><a href="#5_91">5、位与法</a></li></ul><li><a href="#_95">三、常见哈希冲突解决方案</a></li><ul><li><a href="#1_96">1、开放定址法</a></li><ul><li><a href="#1_97">1）原理讲解</a></li><li><a href="#2_100">2）动画演示</a></li></ul><li><a href="#2_105">2、再散列函数法</a></li><ul><li><a href="#1_106">1）原理讲解</a></li><li><a href="#2_108">2）动画演示</a></li></ul><li><a href="#3_110">3、链地址法</a></li><ul><li><a href="#1_111">1）原理讲解</a></li><li><a href="#2_113">2）动画演示</a></li></ul><li><a href="#4_116">4、公共溢出区法</a></li><ul><li><a href="#1_117">1）原理讲解</a></li><li><a href="#2_120">2）动画演示</a></li></ul></ul><li><a href="#_122">四、哈希表的实现</a></li><ul><li><a href="#1_123">1、数据结构定义</a></li><li><a href="#2_141">2、哈希表初始化</a></li><li><a href="#3_153">3、哈希函数计算</a></li><li><a href="#4_160">4、哈希表查找</a></li><li><a href="#5_183">5、哈希表插入</a></li><li><a href="#6_205">6、哈希表删除</a></li><li><a href="#7_219">7、哈希表完整实现</a></li></ul><li><a href="#_286">五、哈希表的入门</a></li><ul><li><a href="#1_287">1、哈希偏移</a></li><li><a href="#2_289">2、字符哈希</a></li><li><a href="#3_291">3、整数哈希</a></li></ul><li><a href="#_293">六、哈希表的进阶</a></li><ul><li><a href="#1_294">1、双指针</a></li><li><a href="#2_297">2、等式转换</a></li><li><a href="#3O1__299">3、O(1) 数据结构的构造</a></li></ul></ul></div><p></p>
<h1><a id="_24"></a>一、哈希表的概念</h1>
<h2><a id="1_25"></a>1、查找算法</h2>
<p>  当我们在一个 <strong>链表</strong> 或者 <strong>顺序表</strong> 中 <strong>查找</strong> 一个数据元素 <strong>是否存在</strong> 的时候，唯一的方法就是遍历整个表，这种方法称为 <strong>线性枚举</strong>。<br>
<img src="https://img-blog.csdnimg.cn/2021052910070993.gif#pic_center" alt=""><br>
  如果这时候，顺序表是有序的情况下，我们可以采用折半的方式去查找，这种方法称为 <strong>二分枚举</strong>。<br>
  <strong>线性枚举</strong> 的时间复杂度为 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></span>。<strong>二分枚举</strong> 的时间复杂度为 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(log_2n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right: 0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: -0.03588em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></span>。是否存在更快速的查找方式呢？这就是本要介绍的一种新的数据结构 —— 哈希表。</p>
<h2><a id="2_30"></a>2、哈希表</h2>
<p>  由于它不是顺序结构，所以很多数据结构书上称之为 <strong>散列表</strong>，下文会统一采用 <strong>哈希表</strong> 的形式来说明，作为读者，只需要知道这两者是同一种数据结构即可。<br>
  我们把需要<strong>查找的数据</strong>，通过一个 <strong>函数映射</strong>，找到 <strong>存储数据的位置</strong> 的过程称为 <strong>哈希</strong>。这里涉及到几个概念：<br>
  a）需要 <strong>查找的数据</strong> 本身被称为 <strong>关键字</strong>；<br>
  b）通过 <strong>函数映射</strong> 将 <strong>关键字</strong> 变成一个 <strong>哈希值</strong> 的过程中，这里的 <strong>函数</strong> 被称为 <strong>哈希函数</strong>；<br>
  c）生成 <strong>哈希值</strong> 的过程过程可能产生冲突，需要进行 <strong>冲突解决</strong>；<br>
  d）解决完冲突以后，实际 <strong>存储数据的位置</strong> 被称为 <strong>哈希地址</strong>，通俗的说，它就是一个数组下标；<br>
  e）存储所有这些数据的数据结构就是 <strong>哈希表</strong>，程序实现上一般采用数组实现，所以又叫 <strong>哈希数组</strong>。整个过程如下图所示：<br>
<img src="https://img-blog.csdnimg.cn/e6a56f91b20c4646b0400496dc003fe5.gif#pic_center" alt=""></p>
<h2><a id="2_40"></a>2、哈希数组</h2>
<p>  为了方便下标索引，<strong>哈希表</strong> 的底层实现结构是一个数组，数组类型可以是任意类型，每个位置被称为一个槽。如下图所示，它代表的是一个长度为 8 的 <strong>哈希表</strong>，又叫 <strong>哈希数组</strong>。</p>
<p><img src="https://img-blog.csdnimg.cn/20210120064654913.png#pic_center" alt=""></p>
<h2><a id="3_44"></a>3、关键字</h2>
<p>  <strong>关键字</strong> 是哈希数组中的元素，可以是任意类型的，它可以是整型、浮点型、字符型、字符串，甚至是结构体或者类。如下的 A、C、M 都可以是关键字；</p>
<pre><code class="prism language-c"><span class="token keyword">int</span> A <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
<span class="token keyword">char</span> C<span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"Hello World!"</span><span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token class-name">Obj</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
Obj M<span class="token punctuation">;</span>
</code></pre>
<p>  哈希表的实现过程中，我们需要通过一些手段，将一个非整型的 <strong>关键字</strong> 转换成 <strong>数组下标</strong>，也就是 <strong>哈希值</strong>，从而通过 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span> 的时间快速索引到它所对应的位置。<br>
  而将一个非整型的 <strong>关键字</strong> 转换成 <strong>整型</strong> 的手段就是 <strong>哈希函数</strong>。</p>
<h2><a id="4_54"></a>4、哈希函数</h2>
<p>  哈希函数可以简单的理解为就是小学课本上那个函数，即 <span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi><mo>=</mo><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">y = f(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.625em; vertical-align: -0.19444em;"></span><span class="mord mathdefault" style="margin-right: 0.03588em;">y</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span></span></span>，这里的 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span></span> 就是哈希函数，<span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">x</span></span></span></span></span> 是关键字，<span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.625em; vertical-align: -0.19444em;"></span><span class="mord mathdefault" style="margin-right: 0.03588em;">y</span></span></span></span></span> 是哈希值。好的哈希函数应该具备以下两个特质：<br>
  a）单射；<br>
  b）雪崩效应：输入值 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">x</span></span></span></span></span> 的 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">1</span></span></span></span></span> 比特的变化，能够造成输出值 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.625em; vertical-align: -0.19444em;"></span><span class="mord mathdefault" style="margin-right: 0.03588em;">y</span></span></span></span></span> 至少一半比特的变化；<br>
  单射很容易理解，图 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mi>a</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(a)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mclose">)</span></span></span></span></span> 中已知哈希值 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.625em; vertical-align: -0.19444em;"></span><span class="mord mathdefault" style="margin-right: 0.03588em;">y</span></span></span></span></span> 时，键 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">x</span></span></span></span></span> 可能有两种情况，不是一个单射；而图 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mi>b</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">b</span><span class="mclose">)</span></span></span></span></span> 中已知哈希值 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.625em; vertical-align: -0.19444em;"></span><span class="mord mathdefault" style="margin-right: 0.03588em;">y</span></span></span></span></span> 时，键 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">x</span></span></span></span></span> 一定是唯一确定的，所以它是单射。由于 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">x</span></span></span></span></span> 和 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.625em; vertical-align: -0.19444em;"></span><span class="mord mathdefault" style="margin-right: 0.03588em;">y</span></span></span></span></span> 一一对应，这样就从本原上减少了冲突。<br>
<img src="https://img-blog.csdnimg.cn/img_convert/1ea359360a97c0deff40a5e4d483e6a9.png#pic_center" alt="">  雪崩效应是为了让哈希值更加符合随机分布的原则，哈希表中的键分布的越随机，利用率越高，效率也越高。<br>
  常用的哈希函数有：<strong>直接定址法</strong>、<strong>除留余数法</strong>、<strong>数字分析法</strong>、<strong>平方取中法</strong>、<strong>折叠法</strong>、<strong>随机数法</strong> 等等。有关哈希函数的内容，下文会进行详细讲解。</p>
<h2><a id="5_61"></a>5、哈希冲突</h2>
<p>  哈希函数在生成 <strong>哈希值</strong> 的过程中，如果产生 <strong>不同的关键字得到相同的哈希值</strong> 的情况，就被称为 <strong>哈希冲突</strong>。<br>
  即对于哈希函数 <span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi><mo>=</mo><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">y = f(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.625em; vertical-align: -0.19444em;"></span><span class="mord mathdefault" style="margin-right: 0.03588em;">y</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span></span></span>，当关键字 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mn>1</mn></msub><mi mathvariant="normal">≠</mi><msub><mi>x</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">x_1 \neq x_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel"><span class="mrel"><span class="mord"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.69444em;"><span class="" style="top: -3em;"><span class="pstrut" style="height: 3em;"></span><span class="rlap"><span class="strut" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="inner"><span class="mrel"></span></span><span class="fix"></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.19444em;"><span class=""></span></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.58056em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>，但是却有 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><msub><mi>x</mi><mn>1</mn></msub><mo stretchy="false">)</mo><mo>=</mo><mi>f</mi><mo stretchy="false">(</mo><msub><mi>x</mi><mn>2</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(x_1) = f(x_2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.10764em;">f</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.10764em;">f</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span>，这时候，我们需要进行冲突解决。<br>
  冲突解决方法有很多，主要有：<strong>开放定址法</strong>、<strong>再散列函数法</strong>、<strong>链地址法</strong>、<strong>公共溢出区法</strong> 等等。有关解决冲突的内容，下文会进行详细讲解。</p>
<h2><a id="6_65"></a>6、哈希地址</h2>
<p>  <strong>哈希地址</strong> 就是一个 <strong>数组下标</strong> ，即哈希数组的下标。通过下标获得数据，被称为 <strong>索引</strong>。通过数据获得下标，被称为 <strong>哈希</strong>。平时工作的时候，和同事交流时用到的一个词 <strong>反查</strong> 就是说的 <strong>哈希</strong>。</p>
<h1><a id="_67"></a>二、常用哈希函数</h1>
<h2><a id="1_68"></a>1、直接定址法</h2>
<p>  <strong>直接定址法</strong> 就是 <strong>关键字</strong> 本身就是 <strong>哈希值</strong>，表示成函数值就是 <span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">f(x) = x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">x</span></span></span></span></span></span>  例如，我们需要统计一个字符串中每个字符的出现次数，就可以通过这种方法。任何一个字符的范围都是 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mn>255</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0, 255]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord">2</span><span class="mord">5</span><span class="mord">5</span><span class="mclose">]</span></span></span></span></span>，所以只要用一个长度为 256 的哈希数组就可以存储每个字符对应的出现次数，利用一次遍历枚举就可以解决这个问题。C代码实现如下：</p>
<pre><code class="prism language-c"><span class="token keyword">int</span> i<span class="token punctuation">,</span> hash<span class="token punctuation">[</span><span class="token number">256</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> str<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token operator">++</span>hash<span class="token punctuation">[</span> str<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>  这个就是最基础的直接定址法的实现。<code>hash[c]</code>代表字符<code>c</code>在这个字符串<code>str</code>中的出现次数。</p>
<h2><a id="2_78"></a>2、平方取中法</h2>
<p>  <strong>平方取中法</strong> 就是对 <strong>关键字</strong> 进行平方，再取中间的某几位作为 <strong>哈希值</strong>。<br>
  例如，对于关键字 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1314</mn></mrow><annotation encoding="application/x-tex">1314</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">1</span><span class="mord">3</span><span class="mord">1</span><span class="mord">4</span></span></span></span></span>，得到平方为 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1726596</mn></mrow><annotation encoding="application/x-tex">1726596</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">1</span><span class="mord">7</span><span class="mord">2</span><span class="mord">6</span><span class="mord">5</span><span class="mord">9</span><span class="mord">6</span></span></span></span></span>，取中间三位作为哈希值，即 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>265</mn></mrow><annotation encoding="application/x-tex">265</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">2</span><span class="mord">6</span><span class="mord">5</span></span></span></span></span>。<br>
  平方取中法 比较适用于 <strong>不清楚关键字的分布，且位数也不是很大</strong> 的情况。</p>
<h2><a id="3_82"></a>3、折叠法</h2>
<p>  <strong>折叠法</strong> 是将关键字分割成位数相等的几部分（注意最后一部分位数不够可以短一些），然后再进行求和，得到一个 <strong>哈希值</strong>。<br>
  例如，对于关键字 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>5201314</mn></mrow><annotation encoding="application/x-tex">5201314</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">5</span><span class="mord">2</span><span class="mord">0</span><span class="mord">1</span><span class="mord">3</span><span class="mord">1</span><span class="mord">4</span></span></span></span></span>，将它分为四组，并且相加得到：<span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>52</mn><mo>+</mo><mn>01</mn><mo>+</mo><mn>31</mn><mo>+</mo><mn>4</mn><mo>=</mo><mn>88</mn></mrow><annotation encoding="application/x-tex">52+01+31+4 = 88</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.72777em; vertical-align: -0.08333em;"></span><span class="mord">5</span><span class="mord">2</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.72777em; vertical-align: -0.08333em;"></span><span class="mord">0</span><span class="mord">1</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.72777em; vertical-align: -0.08333em;"></span><span class="mord">3</span><span class="mord">1</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">4</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">8</span><span class="mord">8</span></span></span></span></span>，这就是哈希值。<br>
  <strong>折叠法</strong> 比较适用于 <strong>不清楚关键字的分布，但是关键字位数较多</strong> 的情况。</p>
<h2><a id="4_87"></a>4、除留余数法</h2>
<p>  <strong>除留余数法</strong> 就是 <strong>关键字</strong> 模上 <strong>哈希表</strong> 长度，表示成函数值就是 <span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>x</mi><mtext>&nbsp;</mtext><mi>m</mi><mi>o</mi><mi>d</mi><mtext>&nbsp;</mtext><mi>m</mi></mrow><annotation encoding="application/x-tex">f(x) = x \ mod \ m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.69444em; vertical-align: 0em;"></span><span class="mord mathdefault">x</span><span class="mspace">&nbsp;</span><span class="mord mathdefault">m</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mspace">&nbsp;</span><span class="mord mathdefault">m</span></span></span></span></span></span>  其中 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">m</span></span></span></span></span> 代表了哈希表的长度，这种方法，不仅可以对关键字直接取模，也可以在 平方取中法、折叠法 之后再取模。<br>
  例如，对于一个长度为 4 的哈希数组，我们可以将关键字 模 4 得到哈希值，如图所示：<br>
<img src="https://img-blog.csdnimg.cn/20210119200007902.png#pic_center" alt=""></p>
<h2><a id="5_91"></a>5、位与法</h2>
<p>  哈希数组的长度一般选择 2 的幂，因为我们知道取模运算是比较耗时的，而位运算相对较为高效。<br>
  选择 2 的幂作为数组长度，可以将 取模运算 转换成 二进制位与。<br>
  令 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mo>=</mo><msup><mn>2</mn><mi>k</mi></msup></mrow><annotation encoding="application/x-tex">m = 2^k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.849108em; vertical-align: 0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.849108em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right: 0.03148em;">k</span></span></span></span></span></span></span></span></span></span></span></span>，那么它的二进制表示就是：<span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mo>=</mo><mo stretchy="false">(</mo><mn>1</mn><munder><munder><mn>000...000</mn><mo stretchy="true">⏟</mo></munder><mi mathvariant="normal">k</mi></munder><msub><mo stretchy="false">)</mo><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">m = (1\underbrace{000...000}_{\rm k})_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 2.08411em; vertical-align: -1.33411em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mord munder"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.64444em;"><span class="" style="top: -1.66589em;"><span class="pstrut" style="height: 3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathrm mtight">k</span></span></span></span></span><span class="" style="top: -3em;"><span class="pstrut" style="height: 3em;"></span><span class="mord munder"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.64444em;"><span class="svg-align" style="top: -2.352em;"><span class="pstrut" style="height: 3em;"></span><span class="stretchy" style="height: 0.548em; min-width: 1.6em;"><span class="brace-left" style="height: 0.548em;"><svg width="400em" height="0.548em" viewBox="0 0 400000 548" preserveAspectRatio="xMinYMin slice"><path d="M0 6l6-6h17c12.688 0 19.313.3 20 1 4 4 7.313 8.3 10 13
 35.313 51.3 80.813 93.8 136.5 127.5 55.688 33.7 117.188 55.8 184.5 66.5.688
 0 2 .3 4 1 18.688 2.7 76 4.3 172 5h399450v120H429l-6-1c-124.688-8-235-61.7
-331-161C60.687 138.7 32.312 99.3 7 54L0 41V6z"></path></svg></span><span class="brace-center" style="height: 0.548em;"><svg width="400em" height="0.548em" viewBox="0 0 400000 548" preserveAspectRatio="xMidYMin slice"><path d="M199572 214
c100.7 8.3 195.3 44 280 108 55.3 42 101.7 93 139 153l9 14c2.7-4 5.7-8.7 9-14
 53.3-86.7 123.7-153 211-199 66.7-36 137.3-56.3 212-62h199568v120H200432c-178.3
 11.7-311.7 78.3-403 201-6 8-9.7 12-11 12-.7.7-6.7 1-18 1s-17.3-.3-18-1c-1.3 0
-5-4-11-12-44.7-59.3-101.3-106.3-170-141s-145.3-54.3-229-60H0V214z"></path></svg></span><span class="brace-right" style="height: 0.548em;"><svg width="400em" height="0.548em" viewBox="0 0 400000 548" preserveAspectRatio="xMaxYMin slice"><path d="M399994 0l6 6v35l-6 11c-56 104-135.3 181.3-238 232-57.3
 28.7-117 45-179 50H-300V214h399897c43.3-7 81-15 113-26 100.7-33 179.7-91 237
-174 2.7-5 6-9 10-13 .7-1 7.3-1 20-1h17z"></path></svg></span></span></span><span class="" style="top: -3em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.648em;"><span class=""></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 1.33411em;"><span class=""></span></span></span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span></span>，任何一个数模上 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">m</span></span></span></span></span>，就相当于取了 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">m</span></span></span></span></span> 的二进制低 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.69444em; vertical-align: 0em;"></span><span class="mord mathdefault" style="margin-right: 0.03148em;">k</span></span></span></span></span> 位，而 <span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mo>−</mo><mn>1</mn><mo>=</mo><mo stretchy="false">(</mo><munder><munder><mn>111...111</mn><mo stretchy="true">⏟</mo></munder><mi mathvariant="normal">k</mi></munder><msub><mo stretchy="false">)</mo><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">m-1 = (\underbrace{111...111}_{\rm k})_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.66666em; vertical-align: -0.08333em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 2.08411em; vertical-align: -1.33411em;"></span><span class="mopen">(</span><span class="mord munder"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.64444em;"><span class="" style="top: -1.66589em;"><span class="pstrut" style="height: 3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathrm mtight">k</span></span></span></span></span><span class="" style="top: -3em;"><span class="pstrut" style="height: 3em;"></span><span class="mord munder"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.64444em;"><span class="svg-align" style="top: -2.352em;"><span class="pstrut" style="height: 3em;"></span><span class="stretchy" style="height: 0.548em; min-width: 1.6em;"><span class="brace-left" style="height: 0.548em;"><svg width="400em" height="0.548em" viewBox="0 0 400000 548" preserveAspectRatio="xMinYMin slice"><path d="M0 6l6-6h17c12.688 0 19.313.3 20 1 4 4 7.313 8.3 10 13
 35.313 51.3 80.813 93.8 136.5 127.5 55.688 33.7 117.188 55.8 184.5 66.5.688
 0 2 .3 4 1 18.688 2.7 76 4.3 172 5h399450v120H429l-6-1c-124.688-8-235-61.7
-331-161C60.687 138.7 32.312 99.3 7 54L0 41V6z"></path></svg></span><span class="brace-center" style="height: 0.548em;"><svg width="400em" height="0.548em" viewBox="0 0 400000 548" preserveAspectRatio="xMidYMin slice"><path d="M199572 214
c100.7 8.3 195.3 44 280 108 55.3 42 101.7 93 139 153l9 14c2.7-4 5.7-8.7 9-14
 53.3-86.7 123.7-153 211-199 66.7-36 137.3-56.3 212-62h199568v120H200432c-178.3
 11.7-311.7 78.3-403 201-6 8-9.7 12-11 12-.7.7-6.7 1-18 1s-17.3-.3-18-1c-1.3 0
-5-4-11-12-44.7-59.3-101.3-106.3-170-141s-145.3-54.3-229-60H0V214z"></path></svg></span><span class="brace-right" style="height: 0.548em;"><svg width="400em" height="0.548em" viewBox="0 0 400000 548" preserveAspectRatio="xMaxYMin slice"><path d="M399994 0l6 6v35l-6 11c-56 104-135.3 181.3-238 232-57.3
 28.7-117 45-179 50H-300V214h399897c43.3-7 81-15 113-26 100.7-33 179.7-91 237
-174 2.7-5 6-9 10-13 .7-1 7.3-1 20-1h17z"></path></svg></span></span></span><span class="" style="top: -3em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.648em;"><span class=""></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 1.33411em;"><span class=""></span></span></span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span></span> ，所以和 位与 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">m-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.66666em; vertical-align: -0.08333em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">1</span></span></span></span></span> 的效果是一样的。即：<span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mtext>&nbsp;</mtext><mi mathvariant="normal">%</mi><mtext>&nbsp;</mtext><mi>S</mi><mo>=</mo><mo>=</mo><mi>x</mi><mtext>&nbsp;</mtext><mi mathvariant="normal">&amp;</mi><mtext>&nbsp;</mtext><mo stretchy="false">(</mo><mi>S</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">x \ \% \ S == x \ \&amp;  \ (S - 1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.80556em; vertical-align: -0.05556em;"></span><span class="mord mathdefault">x</span><span class="mspace">&nbsp;</span><span class="mord">%</span><span class="mspace">&nbsp;</span><span class="mord mathdefault" style="margin-right: 0.05764em;">S</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height: 0.36687em; vertical-align: 0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault">x</span><span class="mspace">&nbsp;</span><span class="mord">&amp;</span><span class="mspace">&nbsp;</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right: 0.05764em;">S</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span></span>  除了直接定址法，其它三种方法都有可能导致哈希冲突，接下来，我们就来讨论下常用的一些哈希冲突的解决方案。</p>
<h1><a id="_95"></a>三、常见哈希冲突解决方案</h1>
<h2><a id="1_96"></a>1、开放定址法</h2>
<h3><a id="1_97"></a>1）原理讲解</h3>
<p>  <strong>开放定址法</strong> 就是一旦发生冲突，就去寻找下一个空的地址，只要哈希表足够大，总能找到一个空的位置，并且记录下来作为它的 <strong>哈希地址</strong>。公式如下：<span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mi>i</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>+</mo><msub><mi>d</mi><mi>i</mi></msub><mo stretchy="false">)</mo><mtext>&nbsp;</mtext><mi>m</mi><mi>o</mi><mi>d</mi><mtext>&nbsp;</mtext><mi>m</mi></mrow><annotation encoding="application/x-tex">f_i(x) = (f(x)+d_i) \ mod \ m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.311664em;"><span class="" style="top: -2.55em; margin-left: -0.10764em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right: 0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.311664em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace">&nbsp;</span><span class="mord mathdefault">m</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mspace">&nbsp;</span><span class="mord mathdefault">m</span></span></span></span></span></span><br>
  这里的 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>d</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">d_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.84444em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.311664em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span> 是一个数列，可以是常数列 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mn>1</mn><mo separator="true">,</mo><mn>1</mn><mo separator="true">,</mo><mn>1</mn><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(1, 1, 1, ...,1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span>，也可以是等差数列<span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mn>3</mn><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><mi>m</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(1,2,3,...,m-1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span>。</p>
<h3><a id="2_100"></a>2）动画演示</h3>
<p><img src="https://img-blog.csdnimg.cn/f07feb636e904adf814afb2f1eede981.gif#pic_center" alt=""></p>
<blockquote>
<p>  上图中，采用的是哈希函数算法是 <strong>除留余数法</strong>，采用的哈希冲突解决方案是 <strong>开放定址法</strong>，哈希表的每个数据就是一个关键字，插入之前需要先进行查找，如果找到的位置未被插入，则执行插入；否则，找到下一个未被插入的位置进行插入；总共插入了 6 个数据，分别为：11、12、13、20、19、28。<br>  这种方法需要注意的是，当插入数据超过哈希表长度时，不能再执行插入。</p>
</blockquote>
<p>  本文在第四章讲解 哈希表的现实 时采用的就是常数列的开放定址法。</p>
<h2><a id="2_105"></a>2、再散列函数法</h2>
<h3><a id="1_106"></a>1）原理讲解</h3>
<p>  <strong>再散列函数法</strong> 就是一旦发生冲突，就采用另一个哈希函数，可以是 平方取中法、折叠法、除留余数法 等等的组合，一般用两个哈希函数，产生冲突的概率已经微乎其微了。<br>  <strong>再散列函数法</strong> 能够使关键字不产生聚集，当然，也会增加不少哈希函数的计算时间。</p>
<h3><a id="2_108"></a>2）动画演示</h3>
<blockquote>
<p>待补充</p>
</blockquote>
<h2><a id="3_110"></a>3、链地址法</h2>
<h3><a id="1_111"></a>1）原理讲解</h3>
<p>  当然，产生冲突后，我们也可以选择不换位置，还是在原来的位置，只是把 <strong>哈希值</strong> 相同的用链表串联起来。这种方法被称为 <strong>链地址法</strong>。</p>
<h3><a id="2_113"></a>2）动画演示</h3>
<p><img src="https://img-blog.csdnimg.cn/3f3079ffb2404a89bf64cf9bdadb8153.gif#pic_center" alt=""></p>
<blockquote>
<p>  上图中，采用的是哈希函数算法是 <strong>除留余数法</strong>，采用的哈希冲突解决方案是 <strong>链地址法</strong>，哈希表的每个数据保留了一个 <strong>链表头结点</strong> 和 <strong>尾结点</strong>，插入之前需要先进行查找，如果找到的位置，链表非空，则插入尾结点并且更新尾结点；否则，生成一个新的链表头结点和尾结点；总共插入了 6 个数据，分别为：11、12、13、20、19、28。</p>
</blockquote>
<h2><a id="4_116"></a>4、公共溢出区法</h2>
<h3><a id="1_117"></a>1）原理讲解</h3>
<p>  一旦产生冲突的数据，统一放到另外一个顺序表中，每次查找数据，在哈希数组中到的关键字和给定关键字相等，则认为查找成功；否则，就去公共溢出区顺序查找，这种方法被称为 <strong>公共溢出区法</strong>。<br>
  这种方法适合冲突较少的情况。</p>
<h3><a id="2_120"></a>2）动画演示</h3>
<blockquote>
<p>待补充</p>
</blockquote>
<h1><a id="_122"></a>四、哈希表的实现</h1>
<h2><a id="1_123"></a>1、数据结构定义</h2>
<p>  由于哈希表的底层存储还是数组，所以我们可以定义一个结构体，结构体中定义一个数组类型的成员，如果需要记录哈希表元素的个数，还可以记录一个 <code>size</code>字段。<br>
  C语言实现如下：</p>
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">maxn</span> <span class="token expression"><span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">&lt;&lt;</span><span class="token number">17</span><span class="token punctuation">)</span>          </span><span class="token comment">// (1)</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">mask</span> <span class="token expression"><span class="token punctuation">(</span>maxn<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>         </span><span class="token comment">// (2)</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">DataType</span> <span class="token expression"><span class="token keyword">int</span>          </span><span class="token comment">// (3)</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">Boolean</span> <span class="token expression"><span class="token keyword">int</span>           </span><span class="token comment">// (4)</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">NULLKEY</span> <span class="token expression"><span class="token punctuation">(</span>maxn<span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">)</span>      </span><span class="token comment">// (5)</span></span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">{</span>
    DataType data<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>HashTable<span class="token punctuation">;</span>
</code></pre>
<ul>
<li><span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span> 利用位运算计算哈希函数进行加速，哈希表的长度为 2 的幂；</li>
<li><span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mn>2</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">2</span><span class="mclose">)</span></span></span></span></span> 利用上文提到的 <strong>位与法</strong> 作为哈希函数，进行位与的掩码必须是二进制表示都是1的，所以等于 2 的幂减一；</li>
<li><span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mn>3</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">3</span><span class="mclose">)</span></span></span></span></span> 定义关键字类型为整型<code>int</code>；</li>
<li><span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mn>4</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(4)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">4</span><span class="mclose">)</span></span></span></span></span> 定义一个布尔变量类型；</li>
<li><span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mn>5</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(5)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">5</span><span class="mclose">)</span></span></span></span></span> <code>NULLKEY</code>作为哈希表对应位置为空时的标记，必须是一个非关键字能取到的值；</li>
</ul>
<h2><a id="2_141"></a>2、哈希表初始化</h2>
<p>  哈希表初始化要做的事情，就是把哈希表的每个位置都置空。C语言代码实现如下：</p>
<pre><code class="prism language-c"><span class="token keyword">void</span> <span class="token function">HashInit</span><span class="token punctuation">(</span>HashTable <span class="token operator">*</span>ht<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> i<span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> maxn<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        ht<span class="token operator">-&gt;</span>data<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> NULLKEY<span class="token punctuation">;</span>      <span class="token comment">// (1)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<ul>
<li><span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span> 将哈希表的每个位置都置空；</li>
</ul>
<h2><a id="3_153"></a>3、哈希函数计算</h2>
<p>  哈希函数计算采用 <strong>除留余数法</strong> 的优化版本 <strong>位与法</strong>。C语言代码实现如下：</p>
<pre><code class="prism language-c"><span class="token keyword">int</span> <span class="token function">HashGetAddr</span><span class="token punctuation">(</span>DataType key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> key <span class="token operator">&amp;</span> mask<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<h2><a id="4_160"></a>4、哈希表查找</h2>
<p>  查找需要采用和插入时相同的哈希冲突方案，即<strong>开放寻址法</strong>。C语言代码实现如下：</p>
<pre><code class="prism language-c">Boolean <span class="token function">HashSearchKey</span><span class="token punctuation">(</span>HashTable <span class="token operator">*</span>ht<span class="token punctuation">,</span> DataType key<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>addr<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> startaddr <span class="token operator">=</span> <span class="token function">HashGetAddr</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// (1)</span>
    <span class="token operator">*</span>addr <span class="token operator">=</span> startaddr<span class="token punctuation">;</span>                   <span class="token comment">// (2)</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>ht<span class="token operator">-&gt;</span>data<span class="token punctuation">[</span><span class="token operator">*</span>addr<span class="token punctuation">]</span> <span class="token operator">!=</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment">// (3)</span>
        <span class="token operator">*</span>addr <span class="token operator">=</span> <span class="token function">HashGetAddr</span><span class="token punctuation">(</span><span class="token operator">*</span>addr <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// (4)</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>ht<span class="token operator">-&gt;</span>data<span class="token punctuation">[</span><span class="token operator">*</span>addr<span class="token punctuation">]</span> <span class="token operator">==</span> NULLKEY<span class="token punctuation">)</span>   <span class="token comment">// (5)</span>
            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>                     
        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">*</span>addr <span class="token operator">==</span> startaddr<span class="token punctuation">)</span>           <span class="token comment">// (6)</span>
            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>                    
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>                            <span class="token comment">// (7)</span>
<span class="token punctuation">}</span>
</code></pre>
<ul>
<li><span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span> 根据 哈希函数<code>HashGetAddr</code>计算得到一个哈希值<code>startaddr</code>；</li>
<li><span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mn>2</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">2</span><span class="mclose">)</span></span></span></span></span> <code>addr</code>是需要作为返回值的，所以要用解引用；</li>
<li><span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mn>3</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">3</span><span class="mclose">)</span></span></span></span></span> 在哈希表的<code>addr</code>对应查找，如果不是空位，则继续 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mn>4</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(4)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">4</span><span class="mclose">)</span></span></span></span></span>；否则，跳出循环；</li>
<li><span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mn>4</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(4)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">4</span><span class="mclose">)</span></span></span></span></span> 往后找一个位置；</li>
<li><span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mn>5</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(5)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">5</span><span class="mclose">)</span></span></span></span></span> 如果发现一个空位，说明这个关键字在哈希表中没有对应数据，直接返回 0，代表查找失败；</li>
<li><span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mn>6</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(6)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">6</span><span class="mclose">)</span></span></span></span></span> 代表整个 <strong>哈希表</strong> 都已经遍历完毕，都没有找到合适的关键字，直接返回 0，代表查找失败；</li>
<li><span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mn>7</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(7)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">7</span><span class="mclose">)</span></span></span></span></span> 否则，返回 1 代表查找成功；</li>
</ul>
<h2><a id="5_183"></a>5、哈希表插入</h2>
<p>  哈希冲突时（即当没有合适位置），就找下一相邻位置，即寻址数列为常数列 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mn>1</mn><mo separator="true">,</mo><mn>1</mn><mo separator="true">,</mo><mn>1</mn><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(1,1,1,...,1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span>。插入需要注意当哈希表慢时，不能再执行插入操作。C语言代码实现如下：</p>
<pre><code class="prism language-c"><span class="token keyword">int</span> <span class="token function">HashInsert</span><span class="token punctuation">(</span>HashTable <span class="token operator">*</span>ht<span class="token punctuation">,</span> DataType key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> addr <span class="token operator">=</span> <span class="token function">HashGetAddr</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>               <span class="token comment">// (1)</span>
    <span class="token keyword">int</span> retaddr<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token function">HashSearchKey</span><span class="token punctuation">(</span>ht<span class="token punctuation">,</span> key<span class="token punctuation">,</span> <span class="token operator">&amp;</span>retaddr <span class="token punctuation">)</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// (2)</span>
        <span class="token keyword">return</span> retaddr<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> 
    <span class="token keyword">while</span><span class="token punctuation">(</span>ht<span class="token operator">-&gt;</span>data<span class="token punctuation">[</span>addr<span class="token punctuation">]</span> <span class="token operator">!=</span> NULLKEY<span class="token punctuation">)</span>           <span class="token comment">// (3)</span>
        addr <span class="token operator">=</span> <span class="token function">HashGetAddr</span><span class="token punctuation">(</span>addr <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment">// (4)</span>
    ht<span class="token operator">-&gt;</span>data<span class="token punctuation">[</span>addr<span class="token punctuation">]</span> <span class="token operator">=</span> key<span class="token punctuation">;</span>                      <span class="token comment">// (5)</span>
    <span class="token keyword">return</span> addr<span class="token punctuation">;</span>                               <span class="token comment">// (6)</span>
<span class="token punctuation">}</span>
</code></pre>
<ul>
<li><span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span> 根据 哈希函数<code>HashGetAddr</code>计算得到一个哈希值<code>addr</code>；</li>
<li><span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mn>2</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">2</span><span class="mclose">)</span></span></span></span></span> 插入前需要先查找是否存在，如果已经存在，则不执行插入；</li>
<li><span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mn>3</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">3</span><span class="mclose">)</span></span></span></span></span> 在哈希表的<code>addr</code>对应查找，如果不是空位，则继续 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mn>3</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">3</span><span class="mclose">)</span></span></span></span></span>；否则，跳出循环；</li>
<li><span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mn>4</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(4)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">4</span><span class="mclose">)</span></span></span></span></span> 往后找一个位置，继续判断是否为空；</li>
<li><span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mn>5</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(5)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">5</span><span class="mclose">)</span></span></span></span></span> 跳出循环则代表当前哈希表的<code>addr</code>位置没有其它元素占据，则可以作为当前<code>key</code>的位置进行插入；</li>
<li><span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mn>6</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(6)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">6</span><span class="mclose">)</span></span></span></span></span> 返回<code>addr</code>作为<code>key</code>的哈希地址；</li>
</ul>
<h2><a id="6_205"></a>6、哈希表删除</h2>
<p>  有了查找的基础，删除操作就比较简单了，如果不能找到一个关键字的位置，则不对哈希表进行任何操作，返回空关键字；否则，将找到的位置赋为空关键字，并且返回删除的位置；</p>
<pre><code class="prism language-c"><span class="token keyword">int</span> <span class="token function">HashRemove</span><span class="token punctuation">(</span>HashTable <span class="token operator">*</span>ht<span class="token punctuation">,</span> DataType key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> addr<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token operator">!</span><span class="token function">HashSearchKey</span><span class="token punctuation">(</span>ht<span class="token punctuation">,</span> key<span class="token punctuation">,</span> <span class="token operator">&amp;</span>addr <span class="token punctuation">)</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token comment">// (1)</span>
        <span class="token keyword">return</span> NULLKEY<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> 
    ht<span class="token operator">-&gt;</span>data<span class="token punctuation">[</span>addr<span class="token punctuation">]</span> <span class="token operator">=</span> NULLKEY<span class="token punctuation">;</span>                    <span class="token comment">// (2)</span>
    <span class="token keyword">return</span> addr<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<ul>
<li><span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span> 首先执行查找；</li>
<li><span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mn>2</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">2</span><span class="mclose">)</span></span></span></span></span> 对找到的位置，将找到位置关键字清空；</li>
</ul>
<h2><a id="7_219"></a>7、哈希表完整实现</h2>
<p>  最后，给出一个 <strong>开放定址法</strong> 的哈希表的完整实现，如下：</p>
<pre><code class="prism language-c"><span class="token comment">/******************** 哈希表 开放定址法 ********************/</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">maxn</span> <span class="token expression"><span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">&lt;&lt;</span><span class="token number">17</span><span class="token punctuation">)</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">mask</span> <span class="token expression"><span class="token punctuation">(</span>maxn<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">DataType</span> <span class="token expression"><span class="token keyword">int</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">Boolean</span> <span class="token expression"><span class="token keyword">int</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">NULLKEY</span> <span class="token expression"><span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">&lt;&lt;</span><span class="token number">30</span><span class="token punctuation">)</span></span></span>

<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">{</span>
    DataType data<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>HashTable<span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">HashInit</span><span class="token punctuation">(</span>HashTable <span class="token operator">*</span>ht<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> i<span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> maxn<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        ht<span class="token operator">-&gt;</span>data<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> NULLKEY<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">HashGetAddr</span><span class="token punctuation">(</span>DataType key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> key <span class="token operator">&amp;</span> mask<span class="token punctuation">;</span> 
<span class="token punctuation">}</span>

Boolean <span class="token function">HashSearchKey</span><span class="token punctuation">(</span>HashTable <span class="token operator">*</span>ht<span class="token punctuation">,</span> DataType key<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>addr<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> startaddr <span class="token operator">=</span> <span class="token function">HashGetAddr</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token operator">*</span>addr <span class="token operator">=</span> startaddr<span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>ht<span class="token operator">-&gt;</span>data<span class="token punctuation">[</span><span class="token operator">*</span>addr<span class="token punctuation">]</span> <span class="token operator">!=</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token operator">*</span>addr <span class="token operator">=</span> <span class="token function">HashGetAddr</span><span class="token punctuation">(</span><span class="token operator">*</span>addr <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>ht<span class="token operator">-&gt;</span>data<span class="token punctuation">[</span><span class="token operator">*</span>addr<span class="token punctuation">]</span> <span class="token operator">==</span> NULLKEY<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">*</span>addr <span class="token operator">==</span> startaddr<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">HashInsert</span><span class="token punctuation">(</span>HashTable <span class="token operator">*</span>ht<span class="token punctuation">,</span> DataType key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> addr <span class="token operator">=</span> <span class="token function">HashGetAddr</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> retaddr<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token function">HashSearchKey</span><span class="token punctuation">(</span>ht<span class="token punctuation">,</span> key<span class="token punctuation">,</span> <span class="token operator">&amp;</span>retaddr <span class="token punctuation">)</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> retaddr<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> 
    <span class="token keyword">while</span><span class="token punctuation">(</span>ht<span class="token operator">-&gt;</span>data<span class="token punctuation">[</span>addr<span class="token punctuation">]</span> <span class="token operator">!=</span> NULLKEY<span class="token punctuation">)</span>
        addr <span class="token operator">=</span> <span class="token function">HashGetAddr</span><span class="token punctuation">(</span>addr <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    ht<span class="token operator">-&gt;</span>data<span class="token punctuation">[</span>addr<span class="token punctuation">]</span> <span class="token operator">=</span> key<span class="token punctuation">;</span>
    <span class="token keyword">return</span> addr<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">HashRemove</span><span class="token punctuation">(</span>HashTable <span class="token operator">*</span>ht<span class="token punctuation">,</span> DataType key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> addr<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token operator">!</span><span class="token function">HashSearchKey</span><span class="token punctuation">(</span>ht<span class="token punctuation">,</span> key<span class="token punctuation">,</span> <span class="token operator">&amp;</span>addr <span class="token punctuation">)</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> NULLKEY<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> 
    ht<span class="token operator">-&gt;</span>data<span class="token punctuation">[</span>addr<span class="token punctuation">]</span> <span class="token operator">=</span> NULLKEY<span class="token punctuation">;</span>
    <span class="token keyword">return</span> addr<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">/******************** 哈希表 开放定址法 ********************/</span>

</code></pre>
<p>  本文介绍的哈希表，是最简单的哈希表，对于刷 LeetCode 已经绰绰有余了，但是如果需要更深入的哈希表相关知识，可以参考以下这篇文章：<a href="https://blog.csdn.net/WhereIsHeroFrom/article/details/112756337">夜深人静写算法（九）- 哈希表</a>。</p>
<h1><a id="_286"></a>五、哈希表的入门</h1>
<h2><a id="1_287"></a>1、哈希偏移</h2>
<p><a href="https://blog.csdn.net/WhereIsHeroFrom/article/details/119810977">LeetCode 525. 连续数组</a></p>
<h2><a id="2_289"></a>2、字符哈希</h2>
<p><a href="https://blog.csdn.net/WhereIsHeroFrom/article/details/119845210">LeetCode 387. 字符串中的第一个唯一字符</a></p>
<h2><a id="3_291"></a>3、整数哈希</h2>
<p><a href="https://blog.csdn.net/WhereIsHeroFrom/article/details/119846168">LeetCode 41. 缺失的第一个正数</a></p>
<h1><a id="_293"></a>六、哈希表的进阶</h1>
<h2><a id="1_294"></a>1、双指针</h2>
<p><a href="https://blog.csdn.net/WhereIsHeroFrom/article/details/119848010">LeetCode 76. 最小覆盖子串</a><br>
<a href="https://blog.csdn.net/WhereIsHeroFrom/article/details/118660229">LeetCode 3. 无重复字符的最长子串</a></p>
<h2><a id="2_297"></a>2、等式转换</h2>
<p><a href="https://blog.csdn.net/WhereIsHeroFrom/article/details/119848016">LeetCode 560. 和为K的子数组</a></p>
<h2><a id="3O1__299"></a>3、O(1) 数据结构的构造</h2>
<p><a href="https://blog.csdn.net/WhereIsHeroFrom/article/details/119848092">LeetCode 380. O(1) 时间插入、删除和获取随机元素</a></p>
<hr>
<p>  关于 <font color="eb3f41"><b>「 哈希表 」</b></font> 的内容到这里就结束了。<br>
  有关<a href="https://blog.csdn.net/whereisherofrom/category_11227297.html"><font color="13ae01"><b>🌳《<u>画解数据结构</u>》🌳 </b></font></a>的源码均开源，链接如下：<a href="https://github.com/WhereIsHeroFrom/Code_Templates/tree/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%94%BB%E8%A7%A3%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">《画解数据结构》</a></p>
<hr>
<center>👇🏻添加 博主 获取付费专栏优惠券👇🏻</center>
</div>
</body>

</html>
