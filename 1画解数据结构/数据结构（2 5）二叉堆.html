<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>《画解数据结构》九张图画解二叉堆</title>
  <link rel="stylesheet" href="https://stackedit.io/style.css" />
</head>

<body class="stackedit">
  <div class="stackedit__html"><center><font><b>本文已收录于专栏</b></font></center><center> <a href="https://blog.csdn.net/whereisherofrom/category_11227297.html"><font color="13ae01"><b>🌳《<u>画解数据结构</u>》🌳 </b></font></a> </center><br>
<h1><a id="_2"></a>前言</h1>
<p>  目前本专栏正在进行优惠活动，在博主主页添加博主好友（好友位没有满的话），可以获取 <font color="red"><strong>付费专栏优惠券</strong></font>。</p>
<blockquote>
<p>  在之前的文章 <a href="https://blog.csdn.net/WhereIsHeroFrom/article/details/120536286"><font color="13ae01"><b>「 <u>二叉搜索树</u> 」 </b></font></a> 中，对于  <font color="13ae01"><b>「 增 」</b></font><font color="FF0500"><b>「 删 」</b></font><font color="ffd700"><b>「 改 」</b></font><font color="2290ff"><b>「 查 」</b></font> 的时间复杂度为 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(log_2n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right: 0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: -0.03588em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></span> ~ <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></span>。原因是最坏情况下，二叉搜索树会退化成 <font color="FFa700"><b>「 线性表 」</b></font> 。更加确切地说，树的高度决定了它插入、删除和查找的时间复杂度。<br>
  本文，我们就来聊一下一种高度始终能够接近 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(log_2n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right: 0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: -0.03588em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></span> 的 <font color="FF4500"><b>「 树形 」</b></font> 的数据结构，它能够在 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span> 的时间内，获得 关键字 最大（或者最小）的元素。并且能够在 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(log_2n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right: 0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: -0.03588em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></span> 的时间内执行插入和删除，一般用来做 优先队列 的实现。它就是：<br><br> </p><center><font size="5" color="2290ff"><b>「  二叉堆 」</b></font></center><br>
<img src="https://img-blog.csdnimg.cn/25f6b74f2d784c629aae0da846a5f682.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA6Iux6ZuE5ZOq6YeM5Ye65p2l,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt=""><br>
<img src="https://img-blog.csdnimg.cn/7308adc349cb4861ac158a949176e899.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA6Iux6ZuE5ZOq6YeM5Ye65p2l,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"><br>
<a href="#jump99"><font size="5" color="ff1f00"><b><u>点击我跳转末尾</u></b></font></a> 获取 <strong>粉丝专属</strong> 《算法和数据结构》源码，以及获取博主的联系方式。<p></p>
</blockquote>
<p></p><div class="toc"><h3>文章目录</h3><ul><li><a href="#_2">前言</a></li><li><a href="#_14">一、堆的概念</a></li><ul><li><a href="#1_15">1、概述</a></li><li><a href="#2_17">2、定义</a></li><li><a href="#3_20">3、性质</a></li><li><a href="#4_28">4、作用</a></li></ul><li><a href="#_30">二、堆的存储结构</a></li><ul><li><a href="#1_37">1、根结点编号</a></li><li><a href="#2_43">2、孩子结点编号</a></li><li><a href="#3_56">3、父结点编号</a></li><li><a href="#4_66">4、数据域</a></li><li><a href="#5_76">5、堆的数据结构</a></li></ul><li><a href="#_89">三、堆的常用接口</a></li><ul><li><a href="#1_90">1、元素比较</a></li><li><a href="#2_105">2、交换元素</a></li><li><a href="#3_115">3、空判定</a></li><li><a href="#4_122">4、满判定</a></li><li><a href="#5_129">5、上浮操作</a></li><li><a href="#6_157">6、下沉操作</a></li></ul><li><a href="#_191">四、堆的创建</a></li><ul><li><a href="#1_192">1、算法描述</a></li><li><a href="#2_194">2、动画演示</a></li><li><a href="#3_197">3、源码详解</a></li></ul><li><a href="#_220">五、堆元素的插入</a></li><ul><li><a href="#1_221">1、算法描述</a></li><li><a href="#2_223">2、动画演示</a></li><li><a href="#3_226">3、源码详解</a></li></ul><li><a href="#_241">五、堆元素的删除</a></li><ul><li><a href="#1_242">1、算法描述</a></li><li><a href="#2_244">2、动画演示</a></li><li><a href="#3_248">3、源码详解</a></li></ul><li><a href="#_262">六、获取堆顶元素</a></li><ul><li><a href="#1_263">1、算法描述</a></li><li><a href="#2_265">2、动画演示</a></li><li><a href="#3_268">3、源码详解</a></li></ul><li><a href="#_277">七、堆的销毁</a></li><ul><li><a href="#1_278">1、算法描述</a></li><li><a href="#2_280">2、动画演示</a></li><li><a href="#3_282">3、源码详解</a></li></ul></ul></div><p></p>
<h1><a id="_14"></a>一、堆的概念</h1>
<h2><a id="1_15"></a>1、概述</h2>
<p>  堆是计算机科学中一类特殊的数据结构的统称。实现有很多，例如：大顶堆，小顶堆，斐波那契堆，左偏堆，斜堆 等等。从子结点个数上可以分为二叉堆，N叉堆等等。本文将介绍的是 二叉堆。</p>
<h2><a id="2_17"></a>2、定义</h2>
<p>  二叉堆本质是一棵完全二叉树，所以每次元素的插入删除都能保证 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(log_2n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right: 0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: -0.03588em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></span>。根据堆的偏序规则，分为 小顶堆 和 大顶堆。小顶堆，顾名思义，根结点的关键字最小；大顶堆则相反。如图所示，表示的是一个大顶堆。<br>
<img src="https://img-blog.csdnimg.cn/b1568afc3fc44d8da86459d54a6f0551.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA6Iux6ZuE5ZOq6YeM5Ye65p2l,size_16,color_FFFFFF,t_70,g_se,x_16#pic_center" alt=""></p>
<h2><a id="3_20"></a>3、性质</h2>
<p>  以大顶堆为例，它总是满足下列性质：<br>
  1）空树是一个大顶堆；<br>
  2）大顶堆中某个结点的关键字 <strong>小于等于</strong> 其父结点的关键字；<br>
  3）大顶堆是一棵完全二叉树。有关完全二叉树的内容，可以参考：<a href="https://blog.csdn.net/WhereIsHeroFrom/article/details/120355101">画解完全二叉树</a>。<br>
如下图所示，任意一个从叶子结点到根结点的路径总是一个单调不降的序列。<br>
<img src="https://img-blog.csdnimg.cn/cfb4941bd7d3481d812b63541b102111.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA6Iux6ZuE5ZOq6YeM5Ye65p2l,size_16,color_FFFFFF,t_70,g_se,x_16#pic_center" alt=""><br>
  小顶堆只要把上文中的 <strong>小于等于</strong> 替换成 <strong>大于等于</strong> 即可。</p>
<h2><a id="4_28"></a>4、作用</h2>
<p>  还是以大顶堆为例，堆能够在 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span> 的时间内，获得 关键字 最大的元素。并且能够在 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(log_2n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right: 0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: -0.03588em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></span> 的时间内执行插入和删除。一般用来做 优先队列 的实现。</p>
<h1><a id="_30"></a>二、堆的存储结构</h1>
<p>  学习堆的过程中，我们能够学到一种新的表示形式。就是：利用 <strong>数组</strong> 来表示 <strong>链式结构</strong>。怎么理解这句话呢？<br>
  由于堆本身是一棵完全二叉树，所以我们可以把每个结点，按照层序映射到一个顺序存储的数组中，然后利用每个结点在数组中的下标，来确定结点之间的关系。<br>
  如图所示，描述的是堆结点下标和结点之间的关系，结点上的数字代表的是 数组下标。从左往右按照层序进行连续递增。<br>
<img src="https://img-blog.csdnimg.cn/f971da23b0cf435ebda5f7d61c0c17d4.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA6Iux6ZuE5ZOq6YeM5Ye65p2l,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt=""></p>
<h2><a id="1_37"></a>1、根结点编号</h2>
<p>  根结点的编号，看作者的喜好。可以用 0 或者 1。本文的作者是 C语言 出身，所以更倾向于选择 0 作为根结点的编号（因为用 1 作为根结点编号的话，数组的第 0 个元素就浪费了）。<br>
  我们可以用一个宏定义来实现它的定义，如下：</p>
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">root</span> <span class="token expression"><span class="token number">0</span></span></span>
</code></pre>
<h2><a id="2_43"></a>2、孩子结点编号</h2>
<p>  那么，根结点的两个左右子树的编号，就分别为 1 和 2 了。以此类推，按照层序进行编号的话，1 的左右子树编号为 3 和 4；2 的左右子树编号为 5 和 6。<br>
  根据数学归纳法，对于编号为 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.65952em; vertical-align: 0em;"></span><span class="mord mathdefault">i</span></span></span></span></span> 的结点，它的左子树编号为 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mi>i</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2i+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.74285em; vertical-align: -0.08333em;"></span><span class="mord">2</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">1</span></span></span></span></span>，右子树编号为 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mi>i</mi><mo>+</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">2i+2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.74285em; vertical-align: -0.08333em;"></span><span class="mord">2</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">2</span></span></span></span></span>。用宏定义实现如下：</p>
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">lson</span><span class="token expression"><span class="token punctuation">(</span>idx<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token number">2</span><span class="token operator">*</span>idx<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">rson</span><span class="token expression"><span class="token punctuation">(</span>idx<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token number">2</span><span class="token operator">*</span>idx<span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">)</span></span></span>
</code></pre>
<p>  由于这里涉及到乘 2，所以我们还可以用左移位运算来优化乘法运算，如下：</p>
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">lson</span><span class="token expression"><span class="token punctuation">(</span>idx<span class="token punctuation">)</span> <span class="token punctuation">(</span>idx <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token operator">|</span><span class="token number">1</span><span class="token punctuation">)</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">rson</span><span class="token expression"><span class="token punctuation">(</span>idx<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>idx <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span></span></span>
</code></pre>
<h2><a id="3_56"></a>3、父结点编号</h2>
<p>  同样，父结点编号也可以通过数学归纳法得出，当结点编号为 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.65952em; vertical-align: 0em;"></span><span class="mord mathdefault">i</span></span></span></span></span> 时，它的父结点编号为 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">\frac {i-1} {2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1.20066em; vertical-align: -0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.855664em;"><span class="" style="top: -2.655em;"><span class="pstrut" style="height: 3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span class="" style="top: -3.23em;"><span class="pstrut" style="height: 3em;"></span><span class="frac-line" style="border-bottom-width: 0.04em;"></span></span><span class="" style="top: -3.394em;"><span class="pstrut" style="height: 3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.345em;"><span class=""></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span>，利用C语言实现如下：</p>
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">parent</span><span class="token expression"><span class="token punctuation">(</span>idx<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>idx <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span></span></span>
</code></pre>
<p>  这里涉及到除 2，可以利用右移运算符进行优化，如下：</p>
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">parent</span><span class="token expression"><span class="token punctuation">(</span>idx<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>idx <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&gt;&gt;</span> <span class="token number">1</span><span class="token punctuation">)</span></span></span>
</code></pre>
<p>  这里利用补码的性质，根结点的父结点得到的值为 -1；</p>
<h2><a id="4_66"></a>4、数据域</h2>
<p>  堆数据元素的数据域可以定义两个：关键字 和 值，其中关键字一般是整数，方便进行比较确定大小关系；值则是用于展示用，可以是任意类型，可以用<code>typedef struct</code>进行定义如下：</p>
<pre><code class="prism language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> key<span class="token punctuation">;</span>      <span class="token comment">// (1)</span>
    <span class="token keyword">void</span> <span class="token operator">*</span>any<span class="token punctuation">;</span>    <span class="token comment">// (2)</span>
<span class="token punctuation">}</span>DataType<span class="token punctuation">;</span>
</code></pre>
<ul>
<li><span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span> 关键字；</li>
<li><span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mn>2</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">2</span><span class="mclose">)</span></span></span></span></span> 值，定义成一个空指针，可以用来表示任意类型；</li>
</ul>
<h2><a id="5_76"></a>5、堆的数据结构</h2>
<p>  由于堆本质上是一棵完全二叉树，所以将它一一映射到数组后，一定是连续的。我们可以用一个数组来代表一个堆，在C语言中的数组拥有一个固定长度，可以用一个<code>Heap</code>结构体表示如下：</p>
<pre><code class="prism language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">{</span>
    DataType <span class="token operator">*</span>data<span class="token punctuation">;</span>  <span class="token comment">// (1)</span>
    <span class="token keyword">int</span> size<span class="token punctuation">;</span>        <span class="token comment">// (2)</span>
    <span class="token keyword">int</span> capacity<span class="token punctuation">;</span>    <span class="token comment">// (3)</span>
<span class="token punctuation">}</span>Heap<span class="token punctuation">;</span>
</code></pre>
<ul>
<li><span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span> 堆元素所在数组的首地址；</li>
<li><span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mn>2</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">2</span><span class="mclose">)</span></span></span></span></span> 堆元素个数；</li>
<li><span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mn>3</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">3</span><span class="mclose">)</span></span></span></span></span> 堆的最大元素个数；</li>
</ul>
<h1><a id="_89"></a>三、堆的常用接口</h1>
<h2><a id="1_90"></a>1、元素比较</h2>
<p>  两个堆元素的比较可以采用一个比较函数<code>compareData</code>来完成，比较过程就是对关键字<code>key</code>进行比较的过程，以大顶堆为例：<br>
  a. 大于返回 -1，代表需要执行交换；<br>
  b. 小于返回 1，代表需要执行交换；<br>
  c. 等于返回 0，代表需要执行交换；</p>
<pre><code class="prism language-c"><span class="token keyword">int</span> <span class="token function">compareData</span><span class="token punctuation">(</span><span class="token keyword">const</span> DataType<span class="token operator">*</span> a<span class="token punctuation">,</span> <span class="token keyword">const</span> DataType<span class="token operator">*</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>a<span class="token operator">-&gt;</span>key <span class="token operator">&gt;</span> b<span class="token operator">-&gt;</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>a<span class="token operator">-&gt;</span>key <span class="token operator">&lt;</span> b<span class="token operator">-&gt;</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<h2><a id="2_105"></a>2、交换元素</h2>
<p>  交换两个元素的位置，也是堆这种数据结构中很常见的操作，C语言实现也比较简单，如下：</p>
<pre><code class="prism language-c"><span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span>DataType<span class="token operator">*</span> a<span class="token punctuation">,</span> DataType<span class="token operator">*</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    DataType tmp <span class="token operator">=</span> <span class="token operator">*</span>a<span class="token punctuation">;</span>
    <span class="token operator">*</span>a <span class="token operator">=</span> <span class="token operator">*</span>b<span class="token punctuation">;</span>
    <span class="token operator">*</span>b <span class="token operator">=</span> tmp<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>  更加详细的内容，可以参考：<a href="https://blog.csdn.net/WhereIsHeroFrom/article/details/121155355">《算法零基础100讲》(第16讲) 变量交换算法</a> 这篇文章。</p>
<h2><a id="3_115"></a>3、空判定</h2>
<p>  空判定是一个查询接口，即询问堆是否是空的，实现如下：</p>
<pre><code class="prism language-c">bool <span class="token function">HeapIsEmpty</span><span class="token punctuation">(</span>Heap <span class="token operator">*</span>heap<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> heap<span class="token operator">-&gt;</span>size <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<h2><a id="4_122"></a>4、满判定</h2>
<p>  满判定是一个查询接口，即询问堆是否是满的，实现如下：</p>
<pre><code class="prism language-c">bool <span class="token function">heapIsFull</span><span class="token punctuation">(</span>Heap <span class="token operator">*</span>heap<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> heap<span class="token operator">-&gt;</span>size <span class="token operator">==</span> heap<span class="token operator">-&gt;</span>capacity<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<h2><a id="5_129"></a>5、上浮操作</h2>
<p>  对于大顶堆而言，从它叶子结点到根结点的元素关键字一定是单调不降的，如果某个元素出现了比它的父结点大的情况，就需要进行上浮操作。<br>
  上浮操作就是对 <strong>当前结点</strong> 和 <strong>父结点</strong> 进行比较，如果它的关键字比父结点大（<code>compareData</code>返回<code>-1</code>的情况），将它和父结点进行交换，继续上浮操作；否则，终止上浮操作。<br>
  如图所示，代表的是一个关键字为 95 的结点，通过不断上浮，到达根结点的过程。上浮完毕以后，它还是一个大顶堆。</p>
<p><img src="https://img-blog.csdnimg.cn/6d561e01d829484eb6dc5e9fe915e494.gif#pic_center" alt=""></p>
<p>  上浮过程的 C语言 实现如下：</p>
<pre><code class="prism language-c"><span class="token keyword">void</span> <span class="token function">heapShiftUp</span><span class="token punctuation">(</span>Heap<span class="token operator">*</span> heap<span class="token punctuation">,</span> <span class="token keyword">int</span> curr<span class="token punctuation">)</span> <span class="token punctuation">{</span>               <span class="token comment">// (1)</span>
    <span class="token keyword">int</span> par <span class="token operator">=</span> <span class="token function">parent</span><span class="token punctuation">(</span>curr<span class="token punctuation">)</span><span class="token punctuation">;</span>                            <span class="token comment">// (2)</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>par <span class="token operator">&gt;=</span> root<span class="token punctuation">)</span> <span class="token punctuation">{</span>                               <span class="token comment">// (3)</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span> <span class="token function">compareData</span><span class="token punctuation">(</span> <span class="token operator">&amp;</span>heap<span class="token operator">-&gt;</span>data<span class="token punctuation">[</span>curr<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>heap<span class="token operator">-&gt;</span>data<span class="token punctuation">[</span>par<span class="token punctuation">]</span> <span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">swap</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>heap<span class="token operator">-&gt;</span>data<span class="token punctuation">[</span>curr<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>heap<span class="token operator">-&gt;</span>data<span class="token punctuation">[</span>par<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// (4) </span>
            curr <span class="token operator">=</span> par<span class="token punctuation">;</span>
            par <span class="token operator">=</span> <span class="token function">parent</span><span class="token punctuation">(</span>curr<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token punctuation">{</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>                                     <span class="token comment">// (5) </span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<ul>
<li><span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span> <code>heapShiftUp</code>这个接口是一个内部接口，所以用小写驼峰区分，用于实现对堆中元素进行插入的时候的上浮操作；</li>
<li><span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mn>2</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">2</span><span class="mclose">)</span></span></span></span></span> <code>curr</code>表示需要进行上浮操作的结点在堆中的编号，<code>par</code>表示<code>curr</code>的父结点编号；</li>
<li><span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mn>3</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">3</span><span class="mclose">)</span></span></span></span></span> 如果已经是根结点，则无须进行上浮操作；</li>
<li><span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mn>4</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(4)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">4</span><span class="mclose">)</span></span></span></span></span> 子结点的关键字 大于 父结点的关键字，则执行交换，并且更新新的 当前结点 和 父结点编号；</li>
<li><span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mn>5</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(5)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">5</span><span class="mclose">)</span></span></span></span></span> 否则，说明已经正确归位，上浮操作结束，跳出循环；</li>
</ul>
<h2><a id="6_157"></a>6、下沉操作</h2>
<p>  对于大顶堆而言，从它 根结点 到 叶子结点 的元素关键字一定是单调不增的，如果某个元素出现了比它的某个子结点小的情况，就需要进行下沉操作。<br>
  下沉操作就是对 <strong>当前结点</strong> 和 <strong>关键字相对较小的子结点</strong> 进行比较，如果它的关键字比子结点小，将它和这个子结点进行交换，继续下沉操作；否则，终止下沉操作。<br>
  如图所示，代表的是一个关键字为 19 的结点，通过不断下沉，到达叶子结点的过程。下沉完毕以后，它还是一个大顶堆。</p>
<p><img src="https://img-blog.csdnimg.cn/fd00178280b5489ba8ba6c91a3cfde76.gif#pic_center" alt=""></p>
<p>  下沉过程的 C语言 实现如下：</p>
<pre><code class="prism language-c"><span class="token keyword">void</span> <span class="token function">heapShiftDown</span><span class="token punctuation">(</span>Heap<span class="token operator">*</span> heap<span class="token punctuation">,</span> <span class="token keyword">int</span> curr<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment">// (1)</span>
    <span class="token keyword">int</span> son <span class="token operator">=</span> <span class="token function">lson</span><span class="token punctuation">(</span>curr<span class="token punctuation">)</span><span class="token punctuation">;</span>                             <span class="token comment">// (2)</span>

    <span class="token keyword">while</span><span class="token punctuation">(</span>son <span class="token operator">&lt;</span> heap<span class="token operator">-&gt;</span>size<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span> <span class="token function">rson</span><span class="token punctuation">(</span>curr<span class="token punctuation">)</span> <span class="token operator">&lt;</span> heap<span class="token operator">-&gt;</span>size <span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span> <span class="token function">compareData</span><span class="token punctuation">(</span> <span class="token operator">&amp;</span>heap<span class="token operator">-&gt;</span>data<span class="token punctuation">[</span><span class="token function">rson</span><span class="token punctuation">(</span>curr<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>heap<span class="token operator">-&gt;</span>data<span class="token punctuation">[</span>son<span class="token punctuation">]</span> <span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>
                son <span class="token operator">=</span> <span class="token function">rson</span><span class="token punctuation">(</span>curr<span class="token punctuation">)</span><span class="token punctuation">;</span>                     <span class="token comment">// (3) </span>
            <span class="token punctuation">}</span>        
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span> <span class="token function">compareData</span><span class="token punctuation">(</span> <span class="token operator">&amp;</span>heap<span class="token operator">-&gt;</span>data<span class="token punctuation">[</span>son<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>heap<span class="token operator">-&gt;</span>data<span class="token punctuation">[</span>curr<span class="token punctuation">]</span> <span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">swap</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>heap<span class="token operator">-&gt;</span>data<span class="token punctuation">[</span>son<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>heap<span class="token operator">-&gt;</span>data<span class="token punctuation">[</span>curr<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// (4)</span>
            curr <span class="token operator">=</span> son<span class="token punctuation">;</span>
            son <span class="token operator">=</span> <span class="token function">lson</span><span class="token punctuation">(</span>curr<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token punctuation">{</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>                                     <span class="token comment">// (5) </span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<ul>
<li><span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span> <code>heapShiftDown</code>这个接口是一个内部接口，所以用小写驼峰区分，用于对堆中元素进行删除的时候的下沉调整；</li>
<li><span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mn>2</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">2</span><span class="mclose">)</span></span></span></span></span> <code>curr</code>表示需要进行下沉操作的结点在堆中的编号，<code>son</code>表示<code>curr</code>的左儿子结点编号；</li>
<li><span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mn>3</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">3</span><span class="mclose">)</span></span></span></span></span> 始终选择关键字更小的子结点；</li>
<li><span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mn>4</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(4)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">4</span><span class="mclose">)</span></span></span></span></span> 子结点的值小于父结点，则执行交换；</li>
<li><span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mn>5</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(5)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">5</span><span class="mclose">)</span></span></span></span></span> 否则，说明已经正确归位，下沉操作结束，跳出循环；</li>
</ul>
<h1><a id="_191"></a>四、堆的创建</h1>
<h2><a id="1_192"></a>1、算法描述</h2>
<p>  通过给定的数据集合，创建堆。可以先创建堆数组的内存空间，然后一个一个执行堆的插入操作。插入操作的具体实现，会在下文继续讲解。</p>
<h2><a id="2_194"></a>2、动画演示</h2>
<p><img src="https://img-blog.csdnimg.cn/2f0feaa4cd3241d193a519bbb3241900.gif#pic_center" alt=""></p>
<h2><a id="3_197"></a>3、源码详解</h2>
<pre><code class="prism language-c">Heap<span class="token operator">*</span> <span class="token function">HeapCreate</span><span class="token punctuation">(</span>DataType <span class="token operator">*</span>data<span class="token punctuation">,</span> <span class="token keyword">int</span> dataSize<span class="token punctuation">,</span> <span class="token keyword">int</span> maxSize<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// (1)</span>
    <span class="token keyword">int</span> i<span class="token punctuation">;</span>
    Heap <span class="token operator">*</span>h <span class="token operator">=</span> <span class="token punctuation">(</span>Heap <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>Heap<span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment">// (2)</span>
    h<span class="token operator">-&gt;</span>data <span class="token operator">=</span> <span class="token punctuation">(</span>DataType <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>DataType<span class="token punctuation">)</span> <span class="token operator">*</span> maxSize <span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// (3)</span>
    h<span class="token operator">-&gt;</span>size <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                                                 <span class="token comment">// (4)</span>
    h<span class="token operator">-&gt;</span>capacity <span class="token operator">=</span> maxSize<span class="token punctuation">;</span>                                       <span class="token comment">// (5)</span>

    <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> dataSize<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">HeapPush</span><span class="token punctuation">(</span>h<span class="token punctuation">,</span> data<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                                    <span class="token comment">// (6)</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> h<span class="token punctuation">;</span>                                                    <span class="token comment">// (7)</span>
<span class="token punctuation">}</span>
</code></pre>
<ul>
<li><span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span> 给定一个元素个数为<code>dataSize</code>的数组<code>data</code>，创建一个最大元素个数为<code>maxSize</code>的堆并返回堆的结构体指针；</li>
<li><span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mn>2</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">2</span><span class="mclose">)</span></span></span></span></span> 利用<code>malloc</code>申请堆的结构体的内存；</li>
<li><span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mn>3</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">3</span><span class="mclose">)</span></span></span></span></span> 利用<code>malloc</code>申请存储堆数据的数组的内存空间；</li>
<li><span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mn>4</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(4)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">4</span><span class="mclose">)</span></span></span></span></span> 初始化空堆；</li>
<li><span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mn>5</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(5)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">5</span><span class="mclose">)</span></span></span></span></span> 初始化堆最大元素个数为<code>maxSize</code>；</li>
<li><span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mn>6</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(6)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">6</span><span class="mclose">)</span></span></span></span></span> 遍历数组执行堆的插入操作，插入的具体实现<code>HeapPush</code>接下来会讲到；</li>
<li><span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mn>7</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(7)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">7</span><span class="mclose">)</span></span></span></span></span> 最后，返回堆的结构体指针；</li>
</ul>
<h1><a id="_220"></a>五、堆元素的插入</h1>
<h2><a id="1_221"></a>1、算法描述</h2>
<p>  堆元素的插入过程，就是先将元素插入堆数组的最后一个位置，然后执行上浮操作；</p>
<h2><a id="2_223"></a>2、动画演示</h2>
<p><img src="https://img-blog.csdnimg.cn/976b6b4017fe42bc860a825024aeb128.gif#pic_center" alt="在这里插入图片描述"></p>
<h2><a id="3_226"></a>3、源码详解</h2>
<pre><code class="prism language-c">bool <span class="token function">HeapPush</span><span class="token punctuation">(</span>Heap<span class="token operator">*</span> heap<span class="token punctuation">,</span> DataType data<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span> <span class="token function">heapIsFull</span><span class="token punctuation">(</span>heap<span class="token punctuation">)</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> false<span class="token punctuation">;</span>                  <span class="token comment">// (1)</span>
    <span class="token punctuation">}</span>
    heap<span class="token operator">-&gt;</span>data<span class="token punctuation">[</span> heap<span class="token operator">-&gt;</span>size<span class="token operator">++</span> <span class="token punctuation">]</span> <span class="token operator">=</span> data<span class="token punctuation">;</span> <span class="token comment">// (2)</span>
    <span class="token function">heapShiftUp</span><span class="token punctuation">(</span>heap<span class="token punctuation">,</span> heap<span class="token operator">-&gt;</span>size<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// (3)</span>
    <span class="token keyword">return</span> true<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<ul>
<li><span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span> 堆已满，不能进行插入；</li>
<li><span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mn>2</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">2</span><span class="mclose">)</span></span></span></span></span> 插入堆数组的最后一个位置；</li>
<li><span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mn>3</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">3</span><span class="mclose">)</span></span></span></span></span> 对最后一个位置的 堆元素 执行上浮操作；</li>
</ul>
<h1><a id="_241"></a>五、堆元素的删除</h1>
<h2><a id="1_242"></a>1、算法描述</h2>
<p>  堆元素的删除，只能对堆顶元素进行操作，可以将数组的最后一个元素放到堆顶，然后对堆顶元素进行下沉操作。</p>
<h2><a id="2_244"></a>2、动画演示</h2>
<p><img src="https://img-blog.csdnimg.cn/9f4dba8764c54cb293a0661518d05950.gif#pic_center" alt="在这里插入图片描述"></p>
<h2><a id="3_248"></a>3、源码详解</h2>
<pre><code class="prism language-c">bool <span class="token function">HeapPop</span><span class="token punctuation">(</span>Heap <span class="token operator">*</span>heap<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">HeapIsEmpty</span><span class="token punctuation">(</span>heap<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> false<span class="token punctuation">;</span>                               <span class="token comment">// (1)</span>
    <span class="token punctuation">}</span>
    heap<span class="token operator">-&gt;</span>data<span class="token punctuation">[</span>root<span class="token punctuation">]</span> <span class="token operator">=</span> heap<span class="token operator">-&gt;</span>data<span class="token punctuation">[</span> <span class="token operator">--</span>heap<span class="token operator">-&gt;</span>size <span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">// (2)</span>
    <span class="token function">heapShiftDown</span><span class="token punctuation">(</span>heap<span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token punctuation">;</span>                      <span class="token comment">// (3)</span>
    <span class="token keyword">return</span> true<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<ul>
<li><span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span> 堆已空，无法执行删除；</li>
<li><span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mn>2</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">2</span><span class="mclose">)</span></span></span></span></span> 将堆数组的最后一个元素放入堆顶，相当于删除了堆顶元素；</li>
<li><span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mn>3</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">3</span><span class="mclose">)</span></span></span></span></span> 对堆顶元素执行下沉操作；</li>
</ul>
<h1><a id="_262"></a>六、获取堆顶元素</h1>
<h2><a id="1_263"></a>1、算法描述</h2>
<p>  获取堆顶元素，就是获取了当前所有元素的最值。</p>
<h2><a id="2_265"></a>2、动画演示</h2>
<p><img src="https://img-blog.csdnimg.cn/a817df7f779540ed82311e6df5e40105.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA6Iux6ZuE5ZOq6YeM5Ye65p2l,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt=""></p>
<h2><a id="3_268"></a>3、源码详解</h2>
<pre><code class="prism language-c">DataType <span class="token function">HeapTop</span><span class="token punctuation">(</span>Heap <span class="token operator">*</span>heap<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// assert(!HeapIsEmpty(heap));</span>
    <span class="token keyword">return</span> heap<span class="token operator">-&gt;</span>data<span class="token punctuation">[</span>root<span class="token punctuation">]</span><span class="token punctuation">;</span>     <span class="token comment">// (1)</span>
<span class="token punctuation">}</span>
</code></pre>
<ul>
<li><span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span> 直接获取数组的第一个元素就是答案了。</li>
</ul>
<h1><a id="_277"></a>七、堆的销毁</h1>
<h2><a id="1_278"></a>1、算法描述</h2>
<p>  销毁时注意释放<code>malloc</code>申请的内存；</p>
<h2><a id="2_280"></a>2、动画演示</h2>
<p>  很遗憾，这个没法动图了。</p>
<h2><a id="3_282"></a>3、源码详解</h2>
<pre><code class="prism language-c"><span class="token keyword">void</span> <span class="token function">HeapFree</span><span class="token punctuation">(</span>Heap <span class="token operator">*</span>heap<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">free</span><span class="token punctuation">(</span>heap<span class="token operator">-&gt;</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">free</span><span class="token punctuation">(</span>heap<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<hr>
<p>  有关 <font color="13ae01"><b>🌳 堆 🌳 </b></font> 的的内容到这里就完全结束了。<br>
  有关<a href="https://blog.csdn.net/whereisherofrom/category_11227297.html"><font color="13ae01"><b>🌳《<u>画解数据结构</u>》🌳 </b></font></a>的源码均开源，链接如下：<a href="https://github.com/WhereIsHeroFrom/Code_Templates/tree/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%94%BB%E8%A7%A3%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">《画解数据结构》</a></p>
<hr>
<center>👇🏻添加 博主 获取付费专栏优惠券👇🏻</center>
</div>
</body>

</html>
