<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>夜深人静写算法（七）- 字典树</title>
  <link rel="stylesheet" href="https://stackedit.io/style.css" />
</head>

<body class="stackedit">
  <div class="stackedit__html"><p></p><div class="toc"><h3>文章目录</h3><ul><li><a href="#_2">一、前言</a></li><li><a href="#_5">二、字典树的原理与实现</a></li><ul><li><a href="#1_6">1、字典树简介</a></li><li><a href="#2_14">2、字典树原理</a></li><ul><li><a href="#1_15">1）字典树结构</a></li><li><a href="#2_26">2）字符串插入</a></li><li><a href="#3_40">3）字符串查询</a></li></ul><li><a href="#3_51">3、字典树实现</a></li><ul><li><a href="#1_52">1）类结构设计</a></li><li><a href="#2_173">2）接口设计</a></li></ul></ul><li><a href="#_222">三、字典树的应用与扩展</a></li><ul><li><a href="#1_223">1、前缀查询</a></li><li><a href="#2_228">2、最短前缀表示</a></li><li><a href="#3_234">3、删除字符串</a></li><li><a href="#4_236">4、删除前缀</a></li><li><a href="#5_242">5、集合前缀</a></li><li><a href="#6_250">6、离线算法</a></li><li><a href="#7_257">7、模糊匹配</a></li><li><a href="#8_272">8、集合最大异或</a></li><li><a href="#9_281">9、树的异或最长路</a></li></ul><li><a href="#_300">四、字典树题集整理</a></li></ul></div><p></p>
<h1><a id="_2"></a>一、前言</h1>
<blockquote>
<p>  我们在写代码的时候，经常会遇到记不住某个变量的名字，然后需要在一段代码里面通过 Ctrl + F 查询某个变量的情况，编辑器在查询这个变量的时候，用到的就是字符串匹配算法，优秀的字符串匹配算法非常多，其中传达的思想也颇为巧妙。<br>  相比 KMP、BM、RK 等字符串匹配算法，<strong>字典树</strong>相对容易理解，又是 AC自动机 的前置技能，而且编码相对简单，对于新手来说，实为一个不错的选择。所以，我打算把它作为字符串匹配算法的敲门砖，放在这一章来讲。<br>  那么，让我们开始吧！为了共同的愿景而努力！<strong>让天下没有难学的算法</strong>！<img src="https://img-blog.csdnimg.cn/20210703122654382.gif#pic_center" alt=""></p>
</blockquote>
<h1><a id="_5"></a>二、字典树的原理与实现</h1>
<h2><a id="1_6"></a>1、字典树简介</h2>
<ul>
<li>字典树，又称 trie 树，是一种树形的数据结构。可以用作词频统计，利用字符串的公共前缀来减少查询时间。一般用来查找某个字符串 S 是否在一个字符串集合中。</li>
</ul>
<blockquote>
<p>【例题1】给定 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo stretchy="false">(</mo><mi>n</mi><mo>&lt;</mo><mo>=</mo><mn>100000</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">n(n &lt;= 100000)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height: 0.36687em; vertical-align: 0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mclose">)</span></span></span></span></span> 个长度不超过 20 的字符串，字符串都由小写字母组成，<span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mo stretchy="false">(</mo><mi>m</mi><mo>&lt;</mo><mo>=</mo><mn>100000</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">m(m&lt;=100000)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault">m</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height: 0.36687em; vertical-align: 0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mclose">)</span></span></span></span></span> 次询问，每次询问给出一个字符串，问这个字符串是否在之前给定的 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">n</span></span></span></span></span> 个字符串中。</p>
</blockquote>
<ul>
<li>这个问题，经常出现在一些网站的搜索引擎中，只不过它把实际问题的规模缩小了。如果把这个 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">n</span></span></span></span></span> 个字符串存下来，每次询问都去这 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">n</span></span></span></span></span> 个字符串里一一匹配查找，最坏时间复杂度为 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>w</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nw)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right: 0.02691em;">w</span><span class="mclose">)</span></span></span></span></span>，其中 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>w</mi></mrow><annotation encoding="application/x-tex">w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault" style="margin-right: 0.02691em;">w</span></span></span></span></span> 为字符串的最大长度，<span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">m</span></span></span></span></span> 次查询下来的总时间复杂度就是 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>m</mi><mi>w</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nmw)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault">m</span><span class="mord mathdefault" style="margin-right: 0.02691em;">w</span><span class="mclose">)</span></span></span></span></span>。实际情况下，字符串的个数以及查询次数肯定远不止这些。</li>
<li>利用字典树，就可以把每次的字符串查找时间控制在 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>w</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(w)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right: 0.02691em;">w</span><span class="mclose">)</span></span></span></span></span>，从而大大降低了查询时间。由于 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">n</span></span></span></span></span> 个字符串存在一个预处理建树的过程，建树的时间复杂度为 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>w</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nw)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right: 0.02691em;">w</span><span class="mclose">)</span></span></span></span></span>，所以整个过程的时间复杂度为 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>w</mi><mo>+</mo><mi>m</mi><mi>w</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nw+mw)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right: 0.02691em;">w</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault" style="margin-right: 0.02691em;">w</span><span class="mclose">)</span></span></span></span></span>。</li>
<li>那么接下来，就让我们来见识下字典树是如何优化查询效率的。</li>
</ul>
<h2><a id="2_14"></a>2、字典树原理</h2>
<h3><a id="1_15"></a>1）字典树结构</h3>
<ul>
<li>首先我们给出一个字符串集合，如下：</li>
</ul>
<blockquote>
<p><strong>trie、tree、try、is、if、even、evening</strong></p>
</blockquote>
<ul>
<li>建立的字典树如图二-2-1所示：<br>
<img src="https://img-blog.csdnimg.cn/img_convert/80fb2c20308f0e02d31139a3eed58423.png#pic_center" alt=""><center>图二-2-1</center></li>
<li>对这个图进行一个简单的介绍，如下：</li>
<li>1）<strong>结点</strong>：为了方便对结点进行索引，每个结点都用一个数字标识；</li>
<li>2）<strong>根结点</strong>：字典树的根结点只有一个，用数字 0 标识；</li>
<li>3）<strong>树边</strong>：字典树的树边上是对应字符串的字母；</li>
<li>4）<strong>结尾结点</strong>：结尾结点即图中的蓝色结点，用于标记一个完整字符串，即 <strong>从根结点到蓝色结点路径上的字母</strong> 所组成的字符串就是字符串集合中的字符串，这个例子中字符串集合有 7 个字符串，所以对应了 7 个蓝色结点。注意：结尾结点并不一定是叶子结点。</li>
</ul>
<h3><a id="2_26"></a>2）字符串插入</h3>
<ul>
<li>对某个字符串插入字典树的过程，就是遍历这个字符串的过程。</li>
</ul>
<blockquote>
<p>插入算法实现如下：<br>  1）定义 <strong>当前结点</strong> 为字典树根结点 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi><mi>o</mi><mi>o</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">root</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.61508em; vertical-align: 0em;"></span><span class="mord mathdefault" style="margin-right: 0.02778em;">r</span><span class="mord mathdefault">o</span><span class="mord mathdefault">o</span><span class="mord mathdefault">t</span></span></span></span></span>，遍历给定字符串 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">s</span></span></span></span></span>；<br>  2）对于字符串第 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.65952em; vertical-align: 0em;"></span><span class="mord mathdefault">i</span></span></span></span></span> 个字符 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">s[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span></span>，查询 <strong>当前结点</strong> 是否有 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">s[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span></span> 这个子结点；<br>   2.a）如果不存在，则创建一个新结点；<br>   2.b）如果存在，不作处理；<br>  3）更新 <strong>当前结点</strong> 为原 <strong>当前结点</strong> 的 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.65952em; vertical-align: 0em;"></span><span class="mord mathdefault">i</span></span></span></span></span> 号子结点；<br>  4）遍历完毕字符串 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">s</span></span></span></span></span> 后在 <strong>当前结点</strong> 打上一个标记，标识 结尾结点；</p>
</blockquote>
<ul>
<li>如上面的例子，字典树初始只有一个根结点，第 1 个插入的字符串为 <strong>trie</strong>，所以得到的字典树是一个链表，如图二-2-2所示：<br>
<img src="https://img-blog.csdnimg.cn/20210110194230350.png#pic_center" alt=""><center>图二-2-2</center></li>
<li>当插入第 2 个字符串 <strong>tree</strong> 时，由于有公共前缀 <strong>tr</strong> 的存在，所以可以少创建两个结点，插入完毕以后如图二-2-3所示：<br>
<img src="https://img-blog.csdnimg.cn/20210110195216618.png#pic_center" alt=""><center>图二-2-3</center></li>
<li>当然，也可以表示成 图二-2-4 所示的树形结构。<br>
<img src="https://img-blog.csdnimg.cn/20210110195612643.png#pic_center" alt=""><center>图二-2-4</center></li>
<li>用同样方法，继续插入 <strong>try</strong>，如图二-2-5所示。<br>
<img src="https://img-blog.csdnimg.cn/20210110195820592.png#pic_center" alt=""><center>图二-2-5</center></li>
<li>当所有字符串都插入完毕，也就构造了一棵完整的字典树，每次插入过程的时间复杂度为 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>w</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(w)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right: 0.02691em;">w</span><span class="mclose">)</span></span></span></span></span>，<span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">n</span></span></span></span></span> 次插入的总时间复杂度为 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>w</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nw)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right: 0.02691em;">w</span><span class="mclose">)</span></span></span></span></span>。</li>
</ul>
<h3><a id="3_40"></a>3）字符串查询</h3>
<ul>
<li>查询某个字符串是否存在，也是遍历这个字符串的过程。</li>
</ul>
<blockquote>
<p>查询算法实现如下：<br>  1）定义 <strong>当前结点</strong> 为字典树根结点 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi><mi>o</mi><mi>o</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">root</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.61508em; vertical-align: 0em;"></span><span class="mord mathdefault" style="margin-right: 0.02778em;">r</span><span class="mord mathdefault">o</span><span class="mord mathdefault">o</span><span class="mord mathdefault">t</span></span></span></span></span>，遍历给定字符串 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">s</span></span></span></span></span>；<br>  2）对于字符串第 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.65952em; vertical-align: 0em;"></span><span class="mord mathdefault">i</span></span></span></span></span> 个字符 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">s[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span></span>，查询 <strong>当前结点</strong> 是否有 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">s[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span></span> 这个子结点；<br>   2.a）如果不存在，则返回 <strong>false</strong>；<br>   2.b）如果存在，不作处理；<br>  3）更新 <strong>当前结点</strong> 为原 <strong>当前结点</strong> 的 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.65952em; vertical-align: 0em;"></span><span class="mord mathdefault">i</span></span></span></span></span> 号子结点；<br>  4）遍历完毕字符串 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">s</span></span></span></span></span> 后在 <strong>当前结点</strong> 上判断是否存在结尾标记，存在则返回 <strong>true</strong>，否则返回 <strong>false</strong>；</p>
</blockquote>
<ul>
<li>例如，在这棵字典树查找字符串 <strong>eval</strong> 时，从根结点开始查询字符 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>e</mi></mrow><annotation encoding="application/x-tex">e</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">e</span></span></span></span></span>，找到结点 11，从 11 的子结点中，查询字符 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault" style="margin-right: 0.03588em;">v</span></span></span></span></span>，找到结点 12，但是，在 12 的子结点中找不到字符 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">a</span></span></span></span></span>，所以字符串 <strong>eval</strong> 查询不到，如图二-2-6所示：<br>
<img src="https://img-blog.csdnimg.cn/img_convert/02da1a74261a8355c2f9b0f023496312.png#pic_center" alt="在这里插入图片描述"><center>图二-2-6</center></li>
<li>再如，查找字符串 <strong>eve</strong> 时，最后查询到结点 13，由于结点 13 没有结尾标记，所以表明 <strong>eve</strong> 只是某个字符串的前缀，并不是一个完整字符串，所以也是查询失败的；而如果查询的字符串为 <strong>even</strong>，由于最终到达的结点 14 是有结尾标记的，所以查询成功，如图二-2-7所示。<br>
<img src="https://img-blog.csdnimg.cn/img_convert/0e4a81515465d9ebcba4a9f8016aee6c.png#pic_center" alt=""><center>图二-2-7</center></li>
</ul>
<h2><a id="3_51"></a>3、字典树实现</h2>
<h3><a id="1_52"></a>1）类结构设计</h3>
<ul>
<li>定义两个类：字典树结点类 和 字典树类；</li>
</ul>
<p><strong>a. 字典树结点类</strong></p>
<ul>
<li>字典树结点包含三个信息：结尾标记、前缀数量、子结点列表，定义如下：</li>
</ul>
<pre><code class="prism language-cpp"><span class="token keyword">const</span> <span class="token keyword">int</span> TRIE_NODE_COUNT <span class="token operator">=</span> <span class="token number">26</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> TRIE_NODE_NULL <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>

<span class="token comment">// 字典树结点类</span>
<span class="token keyword">class</span> <span class="token class-name">TrieNode</span> <span class="token punctuation">{</span>
<span class="token keyword">private</span><span class="token operator">:</span>
    <span class="token keyword">bool</span> isword_<span class="token punctuation">;</span>                 <span class="token comment">// 是否是1个完整字符串</span>
    <span class="token keyword">int</span> num_<span class="token punctuation">;</span>                     <span class="token comment">// 有多少个单次经过这个结点</span>
    <span class="token keyword">int</span> nodes_<span class="token punctuation">[</span>TRIE_NODE_COUNT<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">// 注意这里存的是结点内存池的下标，相比存指针的好处是：字节数少一半</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">resetData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        num_ <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        isword_ <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">reset</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">resetData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">memset</span><span class="token punctuation">(</span>nodes_<span class="token punctuation">,</span> TRIE_NODE_NULL<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>nodes_<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 接口部分暂时省略</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre>
<ul>
<li><code>isword_</code>代表结尾标记，是一个布尔值，当插入一个完整的字符串后，在对应的结点的这个标记置上 <code>true</code>；</li>
<li>令从根结点到这个结点的路径上的字母组成的字符串为 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">s</span></span></span></span></span>，那么 <code>num_</code>就代表了整个字典中有多少个以 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">s</span></span></span></span></span> 为前缀的字符串；</li>
<li><code>nodes_[TRIE_NODE_COUNT]</code>则是一个连续的数组，用来存储结点的每个子结点的编号，也可以认为是指向子结点的指针，之所以没有用 <code>TrieNode*</code>，是因为 int 占 4 个字节，相比指针（64位机器下指针是 8 个字节）省一半内存；</li>
<li>提供一个初始化函数<code>reset()</code>，将结点默认到初始化状态；</li>
<li>由于字符集是有限的，所以可以把字符集映射到下标，提供一个映射函数来实现字符到下标的转换：</li>
</ul>
<p><strong>小写字母的下标映射</strong></p>
<pre><code class="prism language-cpp"><span class="token keyword">typedef</span> <span class="token keyword">const</span> <span class="token keyword">char</span> ValueType<span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> TRIE_NODE_COUNT <span class="token operator">=</span> <span class="token number">26</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">trieNodeValueHash</span><span class="token punctuation">(</span>ValueType v<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> v <span class="token operator">-</span> <span class="token string">'a'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p><strong>大写字母的下标映射</strong></p>
<pre><code class="prism language-cpp"><span class="token keyword">typedef</span> <span class="token keyword">const</span> <span class="token keyword">char</span> ValueType<span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> TRIE_NODE_COUNT <span class="token operator">=</span> <span class="token number">26</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">trieNodeValueHash</span><span class="token punctuation">(</span>ValueType v<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> v <span class="token operator">-</span> <span class="token string">'A'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p><strong>大小写字母混合的下标映射</strong></p>
<pre><code class="prism language-cpp"><span class="token keyword">typedef</span> <span class="token keyword">const</span> <span class="token keyword">char</span> ValueType<span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> TRIE_NODE_COUNT <span class="token operator">=</span> <span class="token number">52</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">trieNodeValueHash</span><span class="token punctuation">(</span>ValueType v<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>v <span class="token operator">&gt;=</span> <span class="token string">'a'</span> <span class="token operator">&amp;&amp;</span> v <span class="token operator">&lt;=</span> <span class="token string">'z'</span><span class="token punctuation">)</span> 
        <span class="token keyword">return</span> v <span class="token operator">-</span> <span class="token string">'a'</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> v <span class="token operator">-</span> <span class="token string">'A'</span> <span class="token operator">+</span> <span class="token number">26</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p><strong>整数字符串的下标映射</strong></p>
<pre><code class="prism language-cpp"><span class="token keyword">typedef</span> <span class="token keyword">int</span> ValueType<span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> TRIE_NODE_COUNT <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">trieNodeValueHash</span><span class="token punctuation">(</span>ValueType v<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> v <span class="token operator">-</span> <span class="token string">'0'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<ul>
<li>如图二-3-1所示，字符集为 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mi>a</mi><mo separator="true">,</mo><mi>z</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[a,z]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord mathdefault" style="margin-right: 0.04398em;">z</span><span class="mclose">]</span></span></span></span></span>， 6 号结点的 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">a</span></span></span></span></span> 子结点不存在，所以 <code>nodes[0] = -1</code>；<span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.69444em; vertical-align: 0em;"></span><span class="mord mathdefault">b</span></span></span></span></span>、<span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.625em; vertical-align: -0.19444em;"></span><span class="mord mathdefault" style="margin-right: 0.03588em;">y</span></span></span></span></span>、<span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>z</mi></mrow><annotation encoding="application/x-tex">z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault" style="margin-right: 0.04398em;">z</span></span></span></span></span> 子结点存在，且 <code>nodes[1] = 7,nodes[24] = 15,nodes[25] = 20</code>。并且 结点 7 和 结点 20 是某个字符串结尾，所以对应的 <code>TrieNode</code>的<code>isword_</code>字段为<code>true</code>。<br>
<img src="https://img-blog.csdnimg.cn/20210111104959123.png#pic_center" alt=""><center>图二-3-1</center></li>
</ul>
<p><strong>b. 字典树类</strong></p>
<ul>
<li>字典树类存储了所有结点信息；</li>
<li>为了避免每次创建结点的时候，从堆上申请内存，我实现的时候，采用一个简单的内存池，并且在类构造时就把内存申请好，申请结点的数量为：字符串数 × 最大字符串长度（<code>TRIE_NODE_CACHES = TRIE_WORD_COUNT * TRIE_WORD_LENGTH</code>）。 当然也可以采用类似 vector 的倍增动态扩容，有兴趣的读者可以自己实现一下，限于篇幅这里就不作展开了。</li>
<li>尤其需要注意的是，如果不采用动态扩容的话，内存池必须预估好量，全程用到的结点数不能超过<code>TRIE_NODE_CACHES</code>，如果结点数大于内存池的大小，是会引起数组下标越界的，这会使得程序进入一个不确定态，是一定要避免的。</li>
</ul>
<pre><code class="prism language-cpp"><span class="token keyword">const</span> <span class="token keyword">int</span> TRIE_WORD_COUNT <span class="token operator">=</span> <span class="token number">400000</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> TRIE_WORD_LENGTH <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> TRIE_NODE_CACHES <span class="token operator">=</span> TRIE_WORD_COUNT <span class="token operator">*</span> TRIE_WORD_LENGTH<span class="token punctuation">;</span>

<span class="token comment">// 字典</span>
树类
<span class="token keyword">class</span> <span class="token class-name">TrieTree</span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token function">TrieTree</span><span class="token punctuation">(</span><span class="token keyword">int</span> nodeCacheCount <span class="token operator">=</span> TRIE_NODE_CACHES<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">virtual</span> <span class="token operator">~</span><span class="token function">TrieTree</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token function">initialize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        nodeId_ <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        root_ <span class="token operator">=</span> <span class="token function">genNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 接口部分暂时省略</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token keyword">private</span><span class="token operator">:</span>
    <span class="token keyword">int</span> <span class="token function">genNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        TrieNode <span class="token operator">*</span>pkNode <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token punctuation">(</span>nodes_<span class="token punctuation">[</span>nodeId_<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        pkNode<span class="token operator">-&gt;</span><span class="token function">reset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> nodeId_<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token keyword">private</span><span class="token operator">:</span>
    <span class="token keyword">int</span> nodeId_<span class="token punctuation">;</span>
    <span class="token keyword">int</span> root_<span class="token punctuation">;</span>
    TrieNode <span class="token operator">*</span>nodes_<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token class-name">TrieTree</span><span class="token operator">::</span><span class="token function">TrieTree</span><span class="token punctuation">(</span><span class="token keyword">int</span> nodeCacheCount <span class="token operator">=</span> TRIE_NODE_CACHES<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">nodes_</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">,</span> 
                                                  <span class="token function">root_</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">nodeId_</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    nodes_ <span class="token operator">=</span> <span class="token keyword">new</span> TrieNode<span class="token punctuation">[</span>nodeCacheCount<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token class-name">TrieTree</span><span class="token operator">::</span><span class="token operator">~</span><span class="token function">TrieTree</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>nodes_<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">delete</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nodes_<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<ul>
<li><code>nodes_</code>指针存储了所有将要用到的字典树结点的内存首地址，在类构造的时候在堆上申请空间；</li>
<li><code>nodeId_</code>则代表了目前已经用掉的结点数，每次调用<code>genNode()</code>返回一个已经初始化好的字典树结点；</li>
</ul>
<h3><a id="2_173"></a>2）接口设计</h3>
<p><strong>a. 字典树的插入</strong></p>
<ul>
<li>字典树的插入在上文已有详细的算法描述，这里先给出代码，然后再来对代码进行解释。</li>
</ul>
<pre><code class="prism language-cpp"><span class="token keyword">typedef</span> <span class="token keyword">const</span> <span class="token keyword">char</span> ValueType<span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token class-name">TrieTree</span><span class="token operator">::</span><span class="token function">insert_word</span><span class="token punctuation">(</span><span class="token keyword">int</span> vSize<span class="token punctuation">,</span> ValueType v<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// 1</span>
    TrieNode <span class="token operator">*</span>pkNow <span class="token operator">=</span> <span class="token function">root</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> vSize<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> nodeIdx <span class="token operator">=</span> <span class="token function">trieNodeValueHash</span><span class="token punctuation">(</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 2</span>
        <span class="token function">checkNode</span><span class="token punctuation">(</span>pkNow<span class="token punctuation">,</span> nodeIdx<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token comment">// 3</span>
        pkNow <span class="token operator">=</span> <span class="token function">node</span><span class="token punctuation">(</span>pkNow<span class="token operator">-&gt;</span><span class="token function">getNode</span><span class="token punctuation">(</span>nodeIdx<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 4</span>
        pkNow<span class="token operator">-&gt;</span><span class="token function">addNum</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                                 <span class="token comment">// 5</span>
    <span class="token punctuation">}</span>
    pkNow<span class="token operator">-&gt;</span><span class="token function">setWord</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                                 <span class="token comment">// 6</span>
<span class="token punctuation">}</span>
</code></pre>
<ul>
<li>1）<code>ValueType</code>由于插入的数据类型不一，所以这里用<code>typedef</code>来定义；</li>
<li>2）<code>trieNodeValueHash</code>用于将原本是非整数类型（或非连续）的数据类型，转换成下标，方便在父结点获取子结点时能通过 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span> 的时间复杂度内获取到；</li>
<li>3）<code>checkNode</code>用于检查当前结点是否存在<code>nodeIdx</code>这个子结点，不存在则创建1个，实现如下：</li>
</ul>
<pre><code class="prism language-cpp"><span class="token keyword">void</span> <span class="token class-name">TrieTree</span><span class="token operator">::</span><span class="token function">checkNode</span><span class="token punctuation">(</span>TrieNode <span class="token operator">*</span>pkNow<span class="token punctuation">,</span> <span class="token keyword">int</span> nodeIdx<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>pkNow<span class="token operator">-&gt;</span><span class="token function">hasNode</span><span class="token punctuation">(</span>nodeIdx<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        pkNow<span class="token operator">-&gt;</span><span class="token function">setNode</span><span class="token punctuation">(</span>nodeIdx<span class="token punctuation">,</span> <span class="token function">genNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<ul>
<li>4）然后将当前结点指针指向<code>nodeIdx</code>子结点；</li>
<li>5）<code>addNum(1)</code>代表前缀标记自增 1；</li>
<li>6）<code>setWord(true)</code>给最后遍历到的结点置上结尾标记；</li>
</ul>
<p><strong>b. 字典树的查询</strong></p>
<ul>
<li>字典树的查询在上文已有详细的算法描述，这里先给出代码，然后再来对代码进行解释。</li>
</ul>
<pre><code class="prism language-cpp"><span class="token keyword">bool</span> <span class="token class-name">TrieTree</span><span class="token operator">::</span><span class="token function">query_word</span><span class="token punctuation">(</span><span class="token keyword">int</span> vSize<span class="token punctuation">,</span> ValueType v<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    TrieNode <span class="token operator">*</span>pkNow <span class="token operator">=</span> <span class="token function">root</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> vSize<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> nodeIdx <span class="token operator">=</span> <span class="token function">trieNodeValueHash</span><span class="token punctuation">(</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">hasNode</span><span class="token punctuation">(</span>pkNow<span class="token punctuation">,</span> nodeIdx<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        pkNow <span class="token operator">=</span> <span class="token function">node</span><span class="token punctuation">(</span>pkNow<span class="token operator">-&gt;</span><span class="token function">getNode</span><span class="token punctuation">(</span>nodeIdx<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> pkNow<span class="token operator">-&gt;</span><span class="token function">isWord</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<ul>
<li>基本和插入算法如出一辙，有两个区别：</li>
<li>1）遍历查询子结点时，如果没有结点，则直接返回 <code>false</code>，不进行创建；</li>
<li>2）遍历完字符串以后，是有返回值的，返回结尾结点的 <code>isword_</code>标记；</li>
</ul>
<h1><a id="_222"></a>三、字典树的应用与扩展</h1>
<h2><a id="1_223"></a>1、前缀查询</h2>
<blockquote>
<p>【例题2】给定 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo stretchy="false">(</mo><mi>n</mi><mo>&lt;</mo><mo>=</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">n(n&lt;=10^5)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height: 0.36687em; vertical-align: 0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1.06411em; vertical-align: -0.25em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.814108em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span> 个长度不超过 20 的小写字母组成的字符串。再给出 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mo stretchy="false">(</mo><mi>m</mi><mo>&lt;</mo><mo>=</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">m(m&lt;=10^5)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault">m</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height: 0.36687em; vertical-align: 0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1.06411em; vertical-align: -0.25em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.814108em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span> 次询问，每次询问一个字符串 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">s</span></span></span></span></span>，求出以 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">s</span></span></span></span></span> 为前缀的字符串有多少个。</p>
</blockquote>
<ul>
<li>由于字典树每个结点都记录了有多少个字符串经过这个结点，即上文提到的<code>num_</code>字段，所以只需要遍历字符串 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">s</span></span></span></span></span>，然后在结尾的结点获取 <code>num_</code>的值，就是以 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">s</span></span></span></span></span> 为前缀的字符串数量。</li>
</ul>
<h2><a id="2_228"></a>2、最短前缀表示</h2>
<blockquote>
<p>【例题3】给定 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo stretchy="false">(</mo><mi>n</mi><mo>&lt;</mo><mo>=</mo><mn>1000</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">n(n&lt;=1000)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height: 0.36687em; vertical-align: 0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mclose">)</span></span></span></span></span> 个长度不超过 20 的小写字母组成的不同字符串，要求给出每个字符串的最短前缀表示，并且不产生冲突（当两个字符串拥有一个公共前缀 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">s</span></span></span></span></span> 时就会产生冲突，<span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">s</span></span></span></span></span> 不能作为两者的最短前缀表示）。</p>
</blockquote>
<ul>
<li>问题可以转化成：对于每个字符串，都要找到这个字符串的一个前缀，使得其它字符串都没有这个前缀，并且使得前缀尽量短。那么对于字符串 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">s</span></span></span></span></span>，只需要找到 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">s</span></span></span></span></span> 的某个前缀，使得前缀最后一个字符对应到字典树所在结点上的 <code>num_</code>为 1 即可，对每个字符串进行遍历字典树的过程。</li>
<li>如图三-2-1所示，橙色数字代表了结点上<code>num_</code>的值。值为 1 的结点，从根结点到这个结点表示的字符串一定可以唯一表示某个字符串。<br>
<img src="https://img-blog.csdnimg.cn/img_convert/98e55e823d5a8d8e8b9c2cda6f6a0c79.png#pic_center" alt=""><center>图三-2-1</center></li>
</ul>
<h2><a id="3_234"></a>3、删除字符串</h2>
<ul>
<li>字符串的删除操作正好是插入操作的逆操作，还是遍历访问字符串，在访问到的结点将 <code>num_</code>值减 1 即可。如果能够将字符串都遍历完毕，则在最后一个结点将 <code>isword_</code>标记置成<code>false</code>。</li>
</ul>
<h2><a id="4_236"></a>4、删除前缀</h2>
<blockquote>
<p>【例题4】度熊手上有一本神奇的字典，你可以在它里面做如下三个操作：<br>  1）insert : 往神奇字典中插入一个单词<br>  2）delete: 在神奇字典中删除所有前缀等于给定字符串的单词<br>  3）search: 查询是否在神奇字典中有一个字符串的前缀等于给定的字符串。</p>
</blockquote>
<ul>
<li>删除给定前缀的字符串，需要考虑这个前缀在字典树中本身就不存在的情况；</li>
<li>首先询问这个字符串是否在字典树存在，并且返回这个字符串的<code>num_</code>计数，然后通过遍历字符串在字典树中将所到路径上的计数都减去，当某个结点计数减到0，说明以这个字符串为前缀的字符串已经不存在了，直接将子结点置成 -1；</li>
</ul>
<h2><a id="5_242"></a>5、集合前缀</h2>
<blockquote>
<p>【例题5】询问一个不重复的字符串集合中，是否有一个串是另一个串的前缀。</p>
</blockquote>
<ul>
<li>很好的利用了前缀树的概念，先将所有字符串插入字典树，然后枚举每个字符串，对每个字符串进行遍历：</li>
<li>1）如果在叶子节点发现 结尾标记，表示是它自己，返回 <code>true</code>；</li>
<li>2）如果在内部结点发现 结尾标记，说明树上某个字符串是当前枚举的字符串的前缀，返回 <code>false</code>；</li>
<li>枚举完所有字符串，一旦出现一次 2） 的情况，表明这个集合中存在有一个串是另一个串的前缀。</li>
</ul>
<h2><a id="6_250"></a>6、离线算法</h2>
<blockquote>
<p>【例题6】给出一个 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>500</mn><mo>×</mo><mn>500</mn></mrow><annotation encoding="application/x-tex">500 \times 500</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.72777em; vertical-align: -0.08333em;"></span><span class="mord">5</span><span class="mord">0</span><span class="mord">0</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">5</span><span class="mord">0</span><span class="mord">0</span></span></span></span></span> 的大写字母矩阵 <strong>R</strong>，再给出 10000 次询问，每次询问一个长度 20 的字符串是否在 R 中出现过（出现过的意思是字符串在矩阵中能够通过横向、竖向、斜向找到），并且返回最小的起始下标。</p>
</blockquote>
<ul>
<li>离线算法在很多场合都有应用，之前讲 并查集、 RMQ 的时候也频频出现了。</li>
<li>对于这个问题，我们简单分析一下，如果用字母矩阵来建立字典树，总的结点数为 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>500</mn><mo>∗</mo><mn>500</mn><mo>∗</mo><mn>20</mn><mo>∗</mo><mn>3</mn><mo>=</mo><mn>1.5</mn><mo>∗</mo><mn>1</mn><msup><mn>0</mn><mn>7</mn></msup></mrow><annotation encoding="application/x-tex">500 * 500 * 20 * 3 = 1.5 * 10^7</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">5</span><span class="mord">0</span><span class="mord">0</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">5</span><span class="mord">0</span><span class="mord">0</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">2</span><span class="mord">0</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">3</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">1</span><span class="mord">.</span><span class="mord">5</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.814108em; vertical-align: 0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.814108em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">7</span></span></span></span></span></span></span></span></span></span></span></span>，内存太大。</li>
<li>那么我们可以将数据全部读入以后，对后面给出的那 10000 个字符串来建立字典树，然后在前面的矩阵中进行询问，这样字典树的结点数只需要 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mo>∗</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">2 * 10^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">2</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.814108em; vertical-align: 0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.814108em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span></span>。</li>
</ul>
<h2><a id="7_257"></a>7、模糊匹配</h2>
<blockquote>
<p>【例题7】一个单词全部由小写字母组成，而一个模式由小写字母、?、* 组成。一个 ? 匹配单个小写字母, 一个 *  匹配零个或多个小写字母，给定 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo stretchy="false">(</mo><mi>n</mi><mo>&lt;</mo><mo>=</mo><mn>100000</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">n(n &lt;= 100000)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height: 0.36687em; vertical-align: 0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mclose">)</span></span></span></span></span> 个模式串，<span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mo stretchy="false">(</mo><mi>m</mi><mo>&lt;</mo><mo>=</mo><mn>100</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">m(m&lt;=100)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault">m</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height: 0.36687em; vertical-align: 0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mclose">)</span></span></span></span></span> 个单词，问每个单词匹配哪几个模式串。</p>
</blockquote>
<ul>
<li>对所有的模式串建立字典树，下标映射函数实现如下：</li>
</ul>
<pre><code class="prism language-cpp"><span class="token keyword">typedef</span> <span class="token keyword">const</span> <span class="token keyword">char</span> ValueType<span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> TRIE_NODE_COUNT <span class="token operator">=</span> <span class="token number">26</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">trieNodeValueHash</span><span class="token punctuation">(</span>ValueType v<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>v <span class="token operator">==</span> <span class="token string">'?'</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">26</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>v <span class="token operator">==</span> <span class="token string">'*'</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">27</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> v <span class="token operator">-</span> <span class="token string">'a'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<ul>
<li>然后对于每个单词，在字典树上进行深度优先搜索即可。</li>
</ul>
<h2><a id="8_272"></a>8、集合最大异或</h2>
<blockquote>
<p>【例题8】 给定 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord mathdefault" style="margin-right: 0.10903em;">N</span></span></span></span></span> 个数 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mi>N</mi><mo>&lt;</mo><mo>=</mo><mn>100000</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(N &lt;=100000)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right: 0.10903em;">N</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height: 0.36687em; vertical-align: 0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mclose">)</span></span></span></span></span>， <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>M</mi><mo stretchy="false">(</mo><mi>M</mi><mo>&lt;</mo><mo>=</mo><mn>100000</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">M (M &lt;= 100000)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.10903em;">M</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right: 0.10903em;">M</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height: 0.36687em; vertical-align: 0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mclose">)</span></span></span></span></span> 次询问，每次询问给出一个正整数 S， 在 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord mathdefault" style="margin-right: 0.10903em;">N</span></span></span></span></span> 个数 中寻找一个数 K ，使得  K 异或 S 的值最大；所有整数不超过 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>32</mn></msup></mrow><annotation encoding="application/x-tex">2^{32}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.814108em; vertical-align: 0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.814108em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span></span>；</p>
</blockquote>
<ul>
<li>1）<span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord mathdefault" style="margin-right: 0.10903em;">N</span></span></span></span></span> 个数都转换成二进制 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>01</mn></mrow><annotation encoding="application/x-tex">01</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">0</span><span class="mord">1</span></span></span></span></span> 字符串，并且用前导零补齐到 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>32</mn></mrow><annotation encoding="application/x-tex">32</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">3</span><span class="mord">2</span></span></span></span></span> 位比特位，执行字典树的插入操作构建一棵 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>01</mn></mrow><annotation encoding="application/x-tex">01</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">0</span><span class="mord">1</span></span></span></span></span> 字典树 (为了把问题描述简单，可以把这里的 32 改小，比如所有数的二进制位最高位 3 位，即数字不超过 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>3</mn></msup></mrow><annotation encoding="application/x-tex">2^{3}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.814108em; vertical-align: 0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.814108em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span></span></span></span></span></span>)；</li>
<li>那么 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mi mathvariant="normal">、</mi><mn>4</mn><mi mathvariant="normal">、</mi><mn>3</mn><mi mathvariant="normal">、</mi><mn>7</mn></mrow><annotation encoding="application/x-tex">1、4、3、7</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">1</span><span class="mord cjk_fallback">、</span><span class="mord">4</span><span class="mord cjk_fallback">、</span><span class="mord">3</span><span class="mord cjk_fallback">、</span><span class="mord">7</span></span></span></span></span> 这四个数就可以构建 001、100、011、111 的字典树；<br>
<img src="https://img-blog.csdnimg.cn/20201212230620225.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1doZXJlSXNIZXJvRnJvbQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><center>图三-8-1</center></li>
<li>2）对于询问的数 S，从最高位开始，如果它的位为1，那么根据异或的性质，要求的 K 对应的二进制位等于0的时候一定比等于1的时候更优（因为是从高位开始计算的）；反之，如果这位等于0 则相反；那么在原字典树中从根节点遍历到叶子节点，如果发现某个最优子节点没有则被迫选择另一个子节点；</li>
<li>3）需要最多的节点数统计；考虑如果 N 个数每个数都没有公共前缀，那么每个数字必然占了 32 个节点，所以最大节点数就是 N * 32（静态节点开辟的时候如果空间开小了可能导致 TLE 超时）；</li>
</ul>
<h2><a id="9_281"></a>9、树的异或最长路</h2>
<blockquote>
<p>【例题9】一棵 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo stretchy="false">(</mo><mn>1</mn><mo>&lt;</mo><mo>=</mo><mi>n</mi><mo>&lt;</mo><mo>=</mo><mn>100000</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">n(1&lt;=n&lt;=100000)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height: 0.36687em; vertical-align: 0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.5782em; vertical-align: -0.0391em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height: 0.36687em; vertical-align: 0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mclose">)</span></span></span></span></span> 个结点的树，定义两者之间的路径长度为路径上所有边权值的异或和，求一条最长异或和路径。<img src="https://img-blog.csdnimg.cn/img_convert/62f2ef426340398da6a4c34b84c5bc5d.png#pic_center" alt="">图中最长异或和路径为：<span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>6</mn><mo>→</mo><mn>7</mn><mo>→</mo><mn>8</mn></mrow><annotation encoding="application/x-tex">6 \to 7\to 8</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">6</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">7</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">8</span></span></span></span></span>，为 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>9</mn><mtext>&nbsp;</mtext><mi>x</mi><mi>o</mi><mi>r</mi><mtext>&nbsp;</mtext><mn>6</mn><mo>=</mo><mn>15</mn></mrow><annotation encoding="application/x-tex">9 \ xor \ 6  = 15</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">9</span><span class="mspace">&nbsp;</span><span class="mord mathdefault">x</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right: 0.02778em;">r</span><span class="mspace">&nbsp;</span><span class="mord">6</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">1</span><span class="mord">5</span></span></span></span></span>。</p>
</blockquote>
<ul>
<li>题目给出的是一颗无根树，先确定一个根 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault" style="margin-right: 0.02778em;">r</span></span></span></span></span>，转换成有根树。程序实现的时候，可以令 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">r = 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault" style="margin-right: 0.02778em;">r</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">0</span></span></span></span></span> 作为根。</li>
<li>根据树的定义，任意两个点之间有且仅有一条路径，所以，对于任意一条路径 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>u</mi><mo>→</mo><mi>v</mi></mrow><annotation encoding="application/x-tex">u \to v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">u</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault" style="margin-right: 0.03588em;">v</span></span></span></span></span>，只要确定两个端点，它们之间的异或和也就确定了。定义 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>u</mi><mo>→</mo><mi>v</mi></mrow><annotation encoding="application/x-tex">u \to v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">u</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault" style="margin-right: 0.03588em;">v</span></span></span></span></span> 路径上所有边的异或和为：<span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>u</mi><mo separator="true">,</mo><mi>v</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(u,v)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord mathdefault" style="margin-right: 0.03588em;">v</span><span class="mclose">)</span></span></span></span></span>。</li>
<li>再根据异或的特性，任意两个相同数的异或和为零，所以 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>u</mi><mo>→</mo><mi>v</mi></mrow><annotation encoding="application/x-tex">u \to v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">u</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault" style="margin-right: 0.03588em;">v</span></span></span></span></span> 的异或和 等于 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>u</mi><mo>→</mo><mi>r</mi></mrow><annotation encoding="application/x-tex">u \to r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">u</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault" style="margin-right: 0.02778em;">r</span></span></span></span></span> 和 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi><mo>→</mo><mi>v</mi></mrow><annotation encoding="application/x-tex">r \to v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault" style="margin-right: 0.02778em;">r</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault" style="margin-right: 0.03588em;">v</span></span></span></span></span> 的异或和，即：<br>
<span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mtable rowspacing="0.24999999999999992em" columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>u</mi><mo separator="true">,</mo><mi>v</mi><mo stretchy="false">)</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mi>f</mi><mo stretchy="false">(</mo><mi>u</mi><mo separator="true">,</mo><mi>r</mi><mo stretchy="false">)</mo><mtext>&nbsp;</mtext><mi>x</mi><mi>o</mi><mi>r</mi><mtext>&nbsp;</mtext><mi>f</mi><mo stretchy="false">(</mo><mi>r</mi><mo separator="true">,</mo><mi>v</mi><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mi>f</mi><mo stretchy="false">(</mo><mi>r</mi><mo separator="true">,</mo><mi>u</mi><mo stretchy="false">)</mo><mtext>&nbsp;</mtext><mi>x</mi><mi>o</mi><mi>r</mi><mtext>&nbsp;</mtext><mi>f</mi><mo stretchy="false">(</mo><mi>r</mi><mo separator="true">,</mo><mi>v</mi><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}f(u,v) &amp;= f(u, r)  \ xor \ f(r, v) \\ &amp;= f(r, u)  \ xor \ f(r, v) \end{aligned}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 3em; vertical-align: -1.25em;"></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.75em;"><span class="" style="top: -3.91em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord mathdefault" style="margin-right: 0.03588em;">v</span><span class="mclose">)</span></span></span><span class="" style="top: -2.41em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 1.25em;"><span class=""></span></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.75em;"><span class="" style="top: -3.91em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mord mathdefault" style="margin-right: 0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord mathdefault" style="margin-right: 0.02778em;">r</span><span class="mclose">)</span><span class="mspace">&nbsp;</span><span class="mord mathdefault">x</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right: 0.02778em;">r</span><span class="mspace">&nbsp;</span><span class="mord mathdefault" style="margin-right: 0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right: 0.02778em;">r</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord mathdefault" style="margin-right: 0.03588em;">v</span><span class="mclose">)</span></span></span><span class="" style="top: -2.41em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mord mathdefault" style="margin-right: 0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right: 0.02778em;">r</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord mathdefault">u</span><span class="mclose">)</span><span class="mspace">&nbsp;</span><span class="mord mathdefault">x</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right: 0.02778em;">r</span><span class="mspace">&nbsp;</span><span class="mord mathdefault" style="margin-right: 0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right: 0.02778em;">r</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord mathdefault" style="margin-right: 0.03588em;">v</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 1.25em;"><span class=""></span></span></span></span></span></span></span></span></span></span></span></span></li>
<li>根据以上特性，从根结点开始一次性遍历所有结点，每遍历到一个结点 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">x</span></span></span></span></span> 计算异或和 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>r</mi><mo separator="true">,</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(r, x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right: 0.02778em;">r</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span></span>，总的时间复杂度为 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></span>。</li>
<li>然后问题就转换成了：从这些 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>r</mi><mo separator="true">,</mo><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mn>0</mn><mo>&lt;</mo><mo>=</mo><mi>x</mi><mo>&lt;</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(r, x) (0 &lt;= x &lt; n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right: 0.02778em;">r</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mopen">(</span><span class="mord">0</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height: 0.36687em; vertical-align: 0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.5782em; vertical-align: -0.0391em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></span> 选出两个值 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>u</mi><mo separator="true">,</mo><mi>v</mi></mrow><annotation encoding="application/x-tex">u,v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.625em; vertical-align: -0.19444em;"></span><span class="mord mathdefault">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord mathdefault" style="margin-right: 0.03588em;">v</span></span></span></span></span>，使得他们的异或 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>r</mi><mo separator="true">,</mo><mi>u</mi><mo stretchy="false">)</mo><mtext>&nbsp;</mtext><mi>x</mi><mi>o</mi><mi>r</mi><mtext>&nbsp;</mtext><mi>f</mi><mo stretchy="false">(</mo><mi>r</mi><mo separator="true">,</mo><mi>v</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(r, u) \ xor \ f(r, v)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right: 0.02778em;">r</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord mathdefault">u</span><span class="mclose">)</span><span class="mspace">&nbsp;</span><span class="mord mathdefault">x</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right: 0.02778em;">r</span><span class="mspace">&nbsp;</span><span class="mord mathdefault" style="margin-right: 0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right: 0.02778em;">r</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord mathdefault" style="margin-right: 0.03588em;">v</span><span class="mclose">)</span></span></span></span></span> 最大。</li>
<li>转换成上面 【例题8】 的字典树求解。</li>
</ul>
<hr>
<ul>
<li>关于 <font color="red"><b>字典树</b></font> 的内容到这里就结束了。</li>
<li>如果还有不懂的问题，可以 <font color="red"><b>想方设法</b></font> 找到作者的微信进行在线咨询。</li>
</ul>
<hr>
<ul>
<li>本文所有示例代码均可在以下 github 上找到：<a href="https://github.com/WhereIsHeroFrom/Code_Templates/tree/master/%E5%AD%97%E7%AC%A6%E4%B8%B2/%E5%AD%97%E5%85%B8%E6%A0%91">github.com/WhereIsHeroFrom/模板/字符串/字典树</a></li>
</ul>
<hr>
<p><img src="https://img-blog.csdnimg.cn/20210105190605774.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1doZXJlSXNIZXJvRnJvbQ==,size_16,color_FFFFFF,t_70" alt=""></p>
<hr>
<h1><a id="_300"></a>四、字典树题集整理</h1>

<table>
<thead>
<tr>
<th>题目链接</th>
<th>难度</th>
<th>解法</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="http://acm.hdu.edu.cn/showproblem.php?pid=2072">HDU 2072 单词数</a></td>
<td>★☆☆☆☆</td>
<td>字典树 模板</td>
</tr>
<tr>
<td><a href="http://poj.org/problem?id=2418">PKU 2418 Hardwood Species</a></td>
<td>★☆☆☆☆</td>
<td>字典树 模板</td>
</tr>
<tr>
<td><a href="http://poj.org/problem?id=2945">PKU 2945 Find the Clones</a></td>
<td>★☆☆☆☆</td>
<td>字典树 模板</td>
</tr>
<tr>
<td><a href="http://poj.org/problem?id=1002">PKU 1002 487-3279</a></td>
<td>★☆☆☆☆</td>
<td>字典树 模板</td>
</tr>
<tr>
<td><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1800">HDU 1800 Flying to the Mars</a></td>
<td>★☆☆☆☆</td>
<td>字典树 模板</td>
</tr>
<tr>
<td><a href="http://poj.org/problem?id=2503">PKU 2503 Babelfish</a></td>
<td>★☆☆☆☆</td>
<td>字典树 的 字符串映射</td>
</tr>
<tr>
<td><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1075">HDU 1075 What Are You Talking About</a></td>
<td>★☆☆☆☆</td>
<td>字典树 的 字符串映射</td>
</tr>
<tr>
<td><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1251">HDU 1251 统计难题</a></td>
<td>★☆☆☆☆</td>
<td>【例题2】字典树 的 前缀统计</td>
</tr>
<tr>
<td><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1298">HDU 1298 T9</a></td>
<td>★★☆☆☆</td>
<td>字典树 + 深搜</td>
</tr>
<tr>
<td><a href="http://poj.org/problem?id=2513">PKU 2513 Colored Sticks</a></td>
<td>★★☆☆☆</td>
<td>字典树+欧拉回路判定</td>
</tr>
<tr>
<td><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1305">HDU 1305 Immediate Decodability</a></td>
<td>★★☆☆☆</td>
<td>【例题5】字典树 的 前缀性质</td>
</tr>
<tr>
<td><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1671">HDU 1671 Phone List</a></td>
<td>★★☆☆☆</td>
<td>字典树 的 前缀性质</td>
</tr>
<tr>
<td><a href="http://acm.hdu.edu.cn/showproblem.php?pid=3724">HDU 3724 Encoded Barcodes</a></td>
<td>★★☆☆☆</td>
<td>字典树 的 前缀性质</td>
</tr>
<tr>
<td><a href="http://poj.org/problem?id=3193">PKU 3193 Cow Phrasebook</a></td>
<td>★★☆☆☆</td>
<td>字典树 的 前缀性质</td>
</tr>
<tr>
<td><a href="http://poj.org/problem?id=2001">PKU 2001 Shortest Prefixes</a></td>
<td>★★☆☆☆</td>
<td>【例题3】字典树 的 最短前缀表示</td>
</tr>
<tr>
<td><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1247">HDU 1247 Hat’s Words</a></td>
<td>★★☆☆☆</td>
<td>字典树 + 深搜</td>
</tr>
<tr>
<td><a href="http://acm.hdu.edu.cn/showproblem.php?pid=4287">HDU 4287 Intelligent IME</a></td>
<td>★★☆☆☆</td>
<td>字典树 + 深搜</td>
</tr>
<tr>
<td><a href="http://poj.org/problem?id=1816">PKU 1816 Wild Words</a></td>
<td>★★★☆☆</td>
<td>【例题7】字典树 + 深搜</td>
</tr>
<tr>
<td><a href="http://acm.hdu.edu.cn/showproblem.php?pid=2846">HDU 2846 Repository</a></td>
<td>★★★☆☆</td>
<td>字典树 的 离线算法</td>
</tr>
<tr>
<td><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1857">HDU 1857 Word Puzzle</a></td>
<td>★★★☆☆</td>
<td>【例题6】字典树 的 离线算法</td>
</tr>
<tr>
<td><a href="http://acm.hdu.edu.cn/showproblem.php?pid=5536">HDU 5536 Chip Factory</a></td>
<td>★★★☆☆</td>
<td>字典树 + 异或最大值</td>
</tr>
<tr>
<td><a href="http://acm.hdu.edu.cn/showproblem.php?pid=4825">HDU 4825 Xor Sum</a></td>
<td>★★★☆☆</td>
<td>【例题8】字典树 + 异或最大值</td>
</tr>
<tr>
<td><a href="http://poj.org/problem?id=3764">PKU 3764 The xor-longest Path</a></td>
<td>★★★☆☆</td>
<td>字【例题9】典树 + 异或最大值</td>
</tr>
<tr>
<td><a href="http://acm.hdu.edu.cn/showproblem.php?pid=4099">HDU 4099 Revenge of Fibonacci</a></td>
<td>★★★☆☆</td>
<td>字典树 + 高精度</td>
</tr>
<tr>
<td><a href="http://acm.hdu.edu.cn/showproblem.php?pid=5687">HDU 5687 Problem C</a></td>
<td>★★★☆☆</td>
<td>【例题4】字典树 的 前缀删除</td>
</tr>
<tr>
<td><a href="http://acm.hdu.edu.cn/showproblem.php?pid=6059">HDU 6059 Kanade’s trio</a></td>
<td>★★★★☆</td>
<td>字典树 + 数位统计</td>
</tr>
<tr>
<td><a href="http://acm.hdu.edu.cn/showproblem.php?pid=6625">HDU 6625 three arrays</a></td>
<td>★★★★☆</td>
<td>字典树 + 数位统计</td>
</tr>
<tr>
<td><a href="http://acm.hdu.edu.cn/showproblem.php?pid=3460">HDU 3460 Ancient Printer</a></td>
<td>★★★★☆</td>
<td>字典树 + 树形DP</td>
</tr>
</tbody>
</table></div>
</body>

</html>
